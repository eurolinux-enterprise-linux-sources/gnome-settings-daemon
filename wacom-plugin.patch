diff -up gnome-settings-daemon-2.28.2/configure.ac.wacom gnome-settings-daemon-2.28.2/configure.ac
--- gnome-settings-daemon-2.28.2/configure.ac.wacom	2012-03-05 16:52:14.732515349 -0500
+++ gnome-settings-daemon-2.28.2/configure.ac	2012-03-05 17:00:55.003596252 -0500
@@ -51,6 +51,7 @@ GCONF_REQUIRED_VERSION=2.6.1
 GIO_REQUIRED_VERSION=2.17.3
 GNOME_DESKTOP_REQUIRED_VERSION=2.26.3
 LIBNOTIFY_REQUIRED_VERSION=0.4.3
+LIBWACOM_REQUIRED_VERSION=0.3
 
 EXTRA_COMPILE_WARNINGS(yes)
 
@@ -306,6 +307,19 @@ fi
 
 AC_SUBST(NSS_DATABASE)
 
+dnl ---------------------------------------------------------------------------
+dnl - wacom
+dnl ---------------------------------------------------------------------------
+
+PKG_CHECK_MODULES(LIBWACOM, [libwacom >= $LIBWACOM_REQUIRED_VERSION x11 xi xtst],
+                  [have_libwacom=true
+                   AC_DEFINE(TABLET_SUPPORT, 1, [Define if tablet support should be enabled])],
+                  [have_libwacom=false])
+
+AM_CONDITIONAL(TABLET_SUPPORT, test "x$have_libwacom" = "xtrue")
+AC_SUBST(LIBWACOM_CFLAGS)
+AC_SUBST(LIBWACOM_LIBS)
+
 # ---------------------------------------------------------------------------
 # Enable Profiling
 # ---------------------------------------------------------------------------
@@ -408,6 +422,7 @@ plugins/mouse/Makefile
 plugins/smartcard/Makefile
 plugins/sound/Makefile
 plugins/typing-break/Makefile
+plugins/wacom/Makefile
 plugins/xrandr/Makefile
 plugins/xrdb/Makefile
 plugins/xrdb/data/Makefile
@@ -449,6 +464,7 @@ echo "
         Smartcard support:        ${have_smartcard_support}
 ${NSS_DATABASE:+\
         System nssdb:             ${NSS_DATABASE}
 }\
+        Tablet support:           ${have_libwacom}
         Profiling support:        ${enable_profiling}
 "
diff -up gnome-settings-daemon-2.28.2/data/desktop_gnome_peripherals_wacom.schemas.in.wacom gnome-settings-daemon-2.28.2/data/desktop_gnome_peripherals_wacom.schemas.in
--- gnome-settings-daemon-2.28.2/data/desktop_gnome_peripherals_wacom.schemas.in.wacom	2012-03-05 16:52:15.271476073 -0500
+++ gnome-settings-daemon-2.28.2/data/desktop_gnome_peripherals_wacom.schemas.in	2012-03-05 16:52:15.271476073 -0500
@@ -0,0 +1,213 @@
+<?xml version="1.0"?>
+<gconfschemafile>
+
+  <schemalist>
+    <schema>
+      <key>/schemas/desktop/gnome/peripherals/wacom/active</key>
+      <owner>gnome</owner>
+      <type>bool</type>
+      <default>TRUE</default>
+      <locale name="C">
+        <short>Activation of this plugin</short>
+        <long>Whether this plugin would be activated by gnome-settings-daemon or not.</long>
+      </locale>
+    </schema>
+
+    <schema>
+      <key>/schemas/desktop/gnome/peripherals/wacom/is-absolute</key>
+      <owner>gnome</owner>
+      <type>bool</type>
+      <default>TRUE</default>
+      <locale name="C">
+        <short>Wacom stylus absolute mode</short>
+        <long>Enable this to set the stylus to absolute mode.</long>
+      </locale>
+    </schema>
+
+    <schema>
+      <key>/schemas/desktop/gnome/peripherals/wacom/area</key>
+      <owner>gnome</owner>
+      <type>list</type>
+      <list_type>int</list_type>
+      <default>[-1, -1, -1, -1]</default>
+      <locale name="C">
+        <short>Wacom tablet area</short>
+        <long>Set this to x1, y1 and x2, y2 of the area usable by the tools.</long>
+      </locale>
+    </schema>
+
+    <schema>
+      <key>/schemas/desktop/gnome/peripherals/wacom/rotation</key>
+      <owner>gnome</owner>
+      <type>string</type>
+      <default>none</default>
+      <locale name="C">
+        <short>Wacom tablet rotation</short>
+        <long>
+          Set this to 'none', 'cw' for 90 degree clockwise,
+          'half' for 180 degree, and 'ccw' for 90 degree counterclockwise.
+        </long>
+      </locale>
+    </schema>
+
+    <schema>
+      <key>/schemas/desktop/gnome/peripherals/wacom/touch</key>
+      <owner>gnome</owner>
+      <type>bool</type>
+      <default>FALSE</default>
+      <locale name="C">
+        <short>Wacom touch feature</short>
+        <long>Enable this to only move the cursor when the user touches the tablet.</long>
+      </locale>
+    </schema>
+
+    <schema>
+      <key>/schemas/desktop/gnome/peripherals/wacom/tablet-pc-button</key>
+      <owner>gnome</owner>
+      <type>bool</type>
+      <default>FALSE</default>
+      <locale name="C">
+        <short>Wacom tablet PC feature</short>
+        <long>Enable this to only report stylus events when the tip is pressed.</long>
+      </locale>
+    </schema>
+
+    <schema>
+      <key>/schemas/desktop/gnome/peripherals/wacom/display</key>
+      <owner>gnome</owner>
+      <type>list</type>
+      <list_type>string</list_type>
+      <default>[,,]</default>
+      <locale name="C">
+        <short>Wacom display mapping</short>
+        <long>
+          EDID information of monitor to map tablet to.
+          Must be in the format [vendor, product, serial]. ["","",""]
+          disables mapping.
+        </long>
+      </locale>
+    </schema>
+
+    <!-- Applies only to the PAD tool -->
+
+    <schema>
+      <key>/schemas/desktop/gnome/peripherals/wacom/pad-buttonmapping</key>
+      <owner>gnome</owner>
+      <type>list</type>
+      <list_type>int</list_type>
+      <default>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]</default>
+      <locale name="C">
+        <short>Wacom pad button mapping</short>
+        <long>Set this to the logical button mapping.</long>
+      </locale>
+    </schema>
+
+    <schema>
+      <key>/schemas/desktop/gnome/peripherals/wacom/stylus/pressurecurve</key>
+      <owner>gnome</owner>
+      <type>list</type>
+      <list_type>int</list_type>
+      <default>[0, 0, 100, 100]</default>
+      <locale name="C">
+        <short>Wacom stylus pressure curve</short>
+        <long>Set this to x1, y1 and x2, y2 of the pressure curve applied to the stylus.</long>
+      </locale>
+    </schema>
+
+    <schema>
+      <key>/schemas/desktop/gnome/peripherals/wacom/stylus/buttonmapping</key>
+      <owner>gnome</owner>
+      <type>list</type>
+      <list_type>int</list_type>
+      <default>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]</default>
+      <locale name="C">
+        <short>Wacom stylus button mapping</short>
+        <long>Set this to the logical button mapping.</long>
+      </locale>
+    </schema>
+
+    <schema>
+      <key>/schemas/desktop/gnome/peripherals/wacom/stylus/pressurethreshold</key>
+      <owner>gnome</owner>
+      <type>int</type>
+      <default>-1</default>
+      <locale name="C">
+        <short>Wacom stylus pressure threshold</short>
+        <long>Set this to the pressure value at which a stylus click event is generated.</long>
+      </locale>
+    </schema>
+
+    <schema>
+      <key>/schemas/desktop/gnome/peripherals/wacom/eraser/pressurecurve</key>
+      <owner>gnome</owner>
+      <type>list</type>
+      <list_type>int</list_type>
+      <default>[0, 0, 100, 100]</default>
+      <locale name="C">
+        <short>Wacom eraser pressure curve</short>
+        <long>Set this to x1, y1 and x2, y2 of the pressure curve applied to the eraser.</long>
+      </locale>
+    </schema>
+
+    <schema>
+      <key>/schemas/desktop/gnome/peripherals/wacom/eraser/buttonmapping</key>
+      <owner>gnome</owner>
+      <type>list</type>
+      <list_type>int</list_type>
+      <default>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]</default>
+      <locale name="C">
+        <short>Wacom eraser button mapping</short>
+        <long>Set this to the logical button mapping.</long>
+      </locale>
+    </schema>
+
+    <schema>
+      <key>/schemas/desktop/gnome/peripherals/wacom/eraser/pressurethreshold</key>
+      <owner>gnome</owner>
+      <type>int</type>
+      <default>-1</default>
+      <locale name="C">
+        <short>Wacom eraser pressure threshold</short>
+        <long>Set this to the pressure value at which a eraser click event is generated.</long>
+      </locale>
+    </schema>
+
+    <schema>
+      <key>/schemas/desktop/gnome/peripherals/wacom/tablet-button/action-type</key>
+      <owner>gnome</owner>
+      <type>string</type>
+      <default>none</default>
+      <locale name="C">
+        <short>Wacom button action type</short>
+        <long>
+          The type of action triggered by the button being pressed,
+          current valid options are 'none' or 'custom'.
+        </long>
+      </locale>
+    </schema>
+
+    <schema>
+      <key>/schemas/desktop/gnome/peripherals/wacom/tablet-button/custom-action</key>
+      <owner>gnome</owner>
+      <type>string</type>
+      <default></default>
+      <locale name="C">
+        <short>Key combination for the custom action</short>
+        <long>The keyboard shortcut generated when the button is pressed for custom actions.</long>
+      </locale>
+    </schema>
+
+    <schema>
+      <key>/schemas/desktop/gnome/peripherals/wacom/tablet-button/custom-elevator-action</key>
+      <owner>gnome</owner>
+      <type>list</type>
+      <list_type>string</list_type>
+      <default>[,]</default>
+      <locale name="C">
+        <short>Key combinations for an elevator custom action</short>
+        <long>The keyboard shortcuts generated when a touchring or touchstrip is used for custom actions (up followed by down).</long>
+      </locale>
+    </schema>
+
+  </schemalist>
+</gconfschemafile>
diff -up gnome-settings-daemon-2.28.2/data/gnome-settings-daemon.schemas.in.wacom gnome-settings-daemon-2.28.2/data/gnome-settings-daemon.schemas.in
--- gnome-settings-daemon-2.28.2/data/gnome-settings-daemon.schemas.in.wacom	2012-03-05 16:52:14.733516082 -0500
+++ gnome-settings-daemon-2.28.2/data/gnome-settings-daemon.schemas.in	2012-03-05 16:52:15.271476073 -0500
@@ -565,6 +565,28 @@
         </long>
       </locale>
     </schema>
+    <schema>
+      <key>/schemas/apps/gnome_settings_daemon/plugins/gsdwacom/active</key>
+      <applyto>/apps/gnome_settings_daemon/plugins/gsdwacom/active</applyto>
+      <owner>gnome-settings-daemon</owner>
+      <type>bool</type>
+      <default>TRUE</default>
+      <locale name="C">
+        <short>Enable Wacom plugin</short>
+        <long>Set to True to enable the plugin to manage Wacom tablets.</long>
+      </locale>
+    </schema>
+    <schema>
+      <key>/schemas/apps/gnome_settings_daemon/plugins/gsdwacom/priority</key>
+      <applyto>/apps/gnome_settings_daemon/plugins/gsdwacom/priority</applyto>
+      <owner>gnome-settings-daemon</owner>
+      <type>int</type>
+      <default>8</default>
+      <locale name="C">
+        <short></short>
+        <long></long>
+      </locale>
+    </schema>
 
   </schemalist>
 </gconfschemafile>
diff -up gnome-settings-daemon-2.28.2/data/Makefile.am.wacom gnome-settings-daemon-2.28.2/data/Makefile.am
--- gnome-settings-daemon-2.28.2/data/Makefile.am.wacom	2012-03-05 16:52:14.732515349 -0500
+++ gnome-settings-daemon-2.28.2/data/Makefile.am	2012-03-05 16:52:15.272476886 -0500
@@ -12,6 +12,7 @@ schemas_in_files = 						\
 	apps_gnome_settings_daemon_xrandr.schemas.in		\
 	desktop_gnome_peripherals_touchpad.schemas.in		\
 	desktop_gnome_peripherals_smartcard.schemas.in		\
+	desktop_gnome_peripherals_wacom.schemas.in		\
 	$(NULL)
 
 schemas_DATA = $(schemas_in_files:.schemas.in=.schemas)
diff -up gnome-settings-daemon-2.28.2/plugins/common/gsd-input-helper.c.wacom gnome-settings-daemon-2.28.2/plugins/common/gsd-input-helper.c
--- gnome-settings-daemon-2.28.2/plugins/common/gsd-input-helper.c.wacom	2012-03-05 16:52:15.273475936 -0500
+++ gnome-settings-daemon-2.28.2/plugins/common/gsd-input-helper.c	2012-03-05 16:52:15.273475936 -0500
@@ -0,0 +1,374 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2010 Bastien Nocera <hadess@hadess.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <gdk/gdk.h>
+#include <gdk/gdkx.h>
+
+#include <sys/types.h>
+#include <X11/Xatom.h>
+#include <X11/extensions/XInput2.h>
+
+#include "gsd-input-helper.h"
+
+typedef gboolean (* InfoIdentifyFunc) (XDeviceInfo *device_info);
+typedef gboolean (* DeviceIdentifyFunc) (XDevice *xdevice);
+
+gboolean
+device_set_property (XDevice        *xdevice,
+                     const char     *device_name,
+                     PropertyHelper *property)
+{
+        int rc, i;
+        Atom prop;
+        Atom realtype;
+        int realformat;
+        unsigned long nitems, bytes_after;
+        unsigned char *data;
+
+        prop = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
+                            property->name, False);
+        if (!prop)
+                return FALSE;
+
+        gdk_error_trap_push ();
+
+        rc = XGetDeviceProperty (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
+                                 xdevice, prop, 0, property->nitems, False,
+                                 AnyPropertyType, &realtype, &realformat, &nitems,
+                                 &bytes_after, &data);
+
+        if (rc != Success ||
+            realtype != property->type ||
+            realformat != property->format ||
+            nitems < property->nitems) {
+                gdk_error_trap_pop ();
+                g_warning ("Error reading property \"%s\" for \"%s\"", property->name, device_name);
+                return FALSE;
+        }
+
+        for (i = 0; i < nitems; i++) {
+                switch (property->format) {
+                        case 8:
+                                data[i] = property->data.c[i];
+                                break;
+                        case 32:
+                                ((long*)data)[i] = property->data.i[i];
+                                break;
+                }
+        }
+
+        XChangeDeviceProperty (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
+                               xdevice, prop, realtype, realformat,
+                               PropModeReplace, data, nitems);
+
+        if (gdk_error_trap_pop ()) {
+                g_warning ("Error in setting \"%s\" for \"%s\"", property->name, device_name);
+                return FALSE;
+        }
+
+        return TRUE;
+}
+
+static gboolean
+supports_xinput_devices_with_opcode (int *opcode)
+{
+        gint op_code, event, error;
+        gboolean retval;
+
+        retval = XQueryExtension (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
+				  "XInputExtension",
+				  &op_code,
+				  &event,
+				  &error);
+	if (opcode)
+		*opcode = op_code;
+
+	return retval;
+}
+
+gboolean
+supports_xinput_devices (int *opcode)
+{
+	return supports_xinput_devices_with_opcode (opcode);
+}
+
+gboolean
+supports_xinput2_devices (int *opcode)
+{
+        int major, minor;
+
+        if (supports_xinput_devices_with_opcode (opcode) == FALSE)
+                return FALSE;
+
+        gdk_error_trap_push ();
+
+        major = 2;
+        minor = 0;
+
+        if (XIQueryVersion (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), &major, &minor) != Success) {
+                gdk_error_trap_pop ();
+                return FALSE;
+        }
+        gdk_error_trap_pop ();
+
+        if ((major * 1000 + minor) < (2000))
+                return FALSE;
+
+        return TRUE;
+}
+
+gboolean
+device_is_touchpad (XDevice *xdevice)
+{
+        Atom realtype, prop;
+        int realformat;
+        unsigned long nitems, bytes_after;
+        unsigned char *data;
+
+        /* we don't check on the type being XI_TOUCHPAD here,
+         * but having a "Synaptics Off" property should be enough */
+
+        prop = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), "Synaptics Off", False);
+        if (!prop)
+                return FALSE;
+
+        gdk_error_trap_push ();
+        if ((XGetDeviceProperty (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), xdevice, prop, 0, 1, False,
+                                XA_INTEGER, &realtype, &realformat, &nitems,
+                                &bytes_after, &data) == Success) && (realtype != None)) {
+                gdk_error_trap_pop ();
+                XFree (data);
+                return TRUE;
+        }
+        gdk_error_trap_pop ();
+
+        return FALSE;
+}
+
+gboolean
+device_info_is_touchpad (XDeviceInfo *device_info)
+{
+        return (device_info->type == XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), XI_TOUCHPAD, False));
+}
+
+gboolean
+device_info_is_touchscreen (XDeviceInfo *device_info)
+{
+        return (device_info->type == XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), XI_TOUCHSCREEN, False));
+}
+
+static gboolean
+device_type_is_present (InfoIdentifyFunc info_func,
+                        DeviceIdentifyFunc device_func)
+{
+        XDeviceInfo *device_info;
+        gint n_devices, opcode;
+        guint i;
+        gboolean retval;
+
+        if (supports_xinput_devices (&opcode) == FALSE)
+                return TRUE;
+
+        retval = FALSE;
+
+        device_info = XListInputDevices (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), &n_devices);
+        if (device_info == NULL)
+                return FALSE;
+
+        for (i = 0; i < n_devices; i++) {
+                XDevice *device;
+
+                /* Check with the device info first */
+                retval = (info_func) (&device_info[i]);
+                if (retval == FALSE)
+                        continue;
+
+                /* If we only have an info func, we're done checking */
+                if (device_func == NULL)
+                        break;
+
+                gdk_error_trap_push ();
+                device = XOpenDevice (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), device_info[i].id);
+                if (gdk_error_trap_pop () || (device == NULL))
+                        continue;
+
+                retval = (device_func) (device);
+                if (retval) {
+                        XCloseDevice (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), device);
+                        break;
+                }
+
+                XCloseDevice (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), device);
+        }
+        XFreeDeviceList (device_info);
+
+        return retval;
+}
+
+gboolean
+touchscreen_is_present (void)
+{
+        return device_type_is_present (device_info_is_touchscreen,
+                                       NULL);
+}
+
+gboolean
+touchpad_is_present (void)
+{
+        return device_type_is_present (device_info_is_touchpad,
+                                       device_is_touchpad);
+}
+
+char *
+xdevice_get_device_node (int deviceid)
+{
+        Atom           prop;
+        Atom           act_type;
+        int            act_format;
+        unsigned long  nitems, bytes_after;
+        unsigned char *data;
+        char          *ret;
+
+        gdk_display_sync (gdk_display_get_default ());
+
+        prop = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), "Device Node", False);
+        if (!prop)
+                return NULL;
+
+        gdk_error_trap_push ();
+
+        if (!XIGetProperty (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
+                            deviceid, prop, 0, 1000, False,
+                            AnyPropertyType, &act_type, &act_format,
+                            &nitems, &bytes_after, &data) == Success) {
+                gdk_error_trap_pop ();
+                return NULL;
+        }
+        if (gdk_error_trap_pop ())
+                goto out;
+
+        if (nitems == 0)
+                goto out;
+
+        if (act_type != XA_STRING)
+                goto out;
+
+        /* Unknown string format */
+        if (act_format != 8)
+                goto out;
+
+        ret = g_strdup ((char *) data);
+
+        XFree (data);
+        return ret;
+
+out:
+        XFree (data);
+        return NULL;
+}
+
+#define STYLUS_DEVICE_ID        0x02
+#define ERASER_DEVICE_ID        0x0A
+
+int
+xdevice_get_last_tool_id (int deviceid)
+{
+        Atom           prop;
+        Atom           act_type;
+        int            act_format;
+        unsigned long  nitems, bytes_after;
+        unsigned char *data, *ptr;
+        int            id;
+
+        id = 0x0;
+
+        gdk_display_sync (gdk_display_get_default ());
+
+        prop = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), WACOM_SERIAL_IDS_PROP, False);
+        if (!prop)
+                return id;
+
+        gdk_error_trap_push ();
+
+        if (!XIGetProperty (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
+                            deviceid, prop, 0, 1000, False,
+                            AnyPropertyType, &act_type, &act_format,
+                            &nitems, &bytes_after, &data) == Success) {
+                gdk_error_trap_pop ();
+                return 0x0;
+        }
+
+        if (gdk_error_trap_pop ())
+                goto out;
+
+	if (nitems != 4)
+		goto out;
+
+	if (act_type != XA_INTEGER)
+		goto out;
+
+	if (act_format != 32)
+		goto out;
+
+	/* item 0 = tablet ID
+	 * item 1 = old device serial number (== last tool in proximity)
+	 * item 2 = old hardware serial number (including tool ID)
+	 * item 3 = current serial number (0 if no tool in proximity) */
+	ptr = data;
+	ptr += act_format/8 * 2;
+
+	id = *((int32_t*)ptr);
+	id = id & 0xfffff;
+
+	/* That means that no tool was set down yet */
+	if (id == STYLUS_DEVICE_ID ||
+	    id == ERASER_DEVICE_ID)
+		return 0x0;
+
+out:
+        XFree (data);
+        return id;
+}
+
+gboolean
+set_device_enabled (int device_id,
+                    gboolean enabled)
+{
+        Atom prop;
+        guchar value;
+
+        prop = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), "Device Enabled", False);
+        if (!prop)
+                return FALSE;
+
+        gdk_error_trap_push ();
+
+        value = enabled ? 1 : 0;
+        XIChangeProperty (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
+                          device_id, prop, XA_INTEGER, 8, PropModeReplace, &value, 1);
+
+        if (gdk_error_trap_pop ())
+                return FALSE;
+
+        return TRUE;
+}
+
diff -up gnome-settings-daemon-2.28.2/plugins/common/gsd-input-helper.h.wacom gnome-settings-daemon-2.28.2/plugins/common/gsd-input-helper.h
--- gnome-settings-daemon-2.28.2/plugins/common/gsd-input-helper.h.wacom	2012-03-05 16:52:15.273475936 -0500
+++ gnome-settings-daemon-2.28.2/plugins/common/gsd-input-helper.h	2012-03-05 16:52:15.273475936 -0500
@@ -0,0 +1,71 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2010 Bastien Nocera <hadess@hadess.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GSD_INPUT_HELPER_H
+#define __GSD_INPUT_HELPER_H
+
+G_BEGIN_DECLS
+
+#include <glib.h>
+
+#include <X11/extensions/XInput.h>
+#include <X11/extensions/XIproto.h>
+
+#define WACOM_SERIAL_IDS_PROP "Wacom Serial IDs"
+
+/* Generic property setting code. Fill up the struct property with the property
+ * data and pass it into device_set_property together with the device to be
+ * changed.  Note: doesn't cater for non-zero offsets yet, but we don't have
+ * any settings that require that.
+ */
+typedef struct {
+        const char *name;       /* property name */
+        gint nitems;            /* number of items in data */
+        gint format;            /* CARD8 or CARD32 sized-items */
+        gint type;              /* Atom representing data type */
+        union {
+                const gchar *c; /* 8 bit data */
+                const gint *i;  /* 32 bit data */
+        } data;
+} PropertyHelper;
+
+gboolean  supports_xinput_devices  (int *opcode);
+gboolean  supports_xinput2_devices (int *opcode);
+
+gboolean set_device_enabled       (int device_id,
+                                   gboolean enabled);
+
+gboolean  device_is_touchpad       (XDevice                *xdevice);
+
+gboolean  device_info_is_touchpad    (XDeviceInfo         *device_info);
+gboolean  device_info_is_touchscreen (XDeviceInfo         *device_info);
+
+gboolean  touchpad_is_present     (void);
+gboolean  touchscreen_is_present  (void);
+
+gboolean  device_set_property     (XDevice                *xdevice,
+                                   const char             *device_name,
+                                   PropertyHelper         *property);
+
+char *    xdevice_get_device_node  (int                     deviceid);
+int       xdevice_get_last_tool_id (int                     deviceid);
+
+G_END_DECLS
+
+#endif /* __GSD_INPUT_HELPER_H */
diff -up gnome-settings-daemon-2.28.2/plugins/common/gsd-keygrab.c.wacom gnome-settings-daemon-2.28.2/plugins/common/gsd-keygrab.c
--- gnome-settings-daemon-2.28.2/plugins/common/gsd-keygrab.c.wacom	2012-03-05 16:52:14.865638288 -0500
+++ gnome-settings-daemon-2.28.2/plugins/common/gsd-keygrab.c	2012-03-05 16:52:15.273475936 -0500
@@ -22,6 +22,7 @@
 
 #include "config.h"
 
+#include <string.h>
 #include <gdk/gdk.h>
 #include <gdk/gdkx.h>
 #ifdef HAVE_X11_EXTENSIONS_XKB_H
@@ -285,3 +286,60 @@ match_key (Key *key, XEvent *event)
                 && key->state == (event->xkey.state & gsd_used_mods)
                 && key_uses_keycode (key, event->xkey.keycode));
 }
+
+static void
+grab_button_real (int        deviceid,
+		  gboolean   grab,
+		  GdkWindow *root)
+{
+	XIGrabModifiers mods;
+
+	mods.modifiers = XIAnyModifier;
+
+	if (grab) {
+		XIEventMask evmask;
+		unsigned char mask[(XI_LASTEVENT + 7)/8];
+
+		memset (mask, 0, sizeof (mask));
+		XISetMask (mask, XI_ButtonRelease);
+		XISetMask (mask, XI_ButtonPress);
+
+		evmask.deviceid = deviceid;
+		evmask.mask_len = sizeof (mask);
+		evmask.mask = mask;
+
+		XIGrabButton (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
+			      deviceid,
+			      XIAnyButton,
+			      GDK_WINDOW_XID (root),
+			      None,
+			      GrabModeAsync,
+			      GrabModeAsync,
+			      False,
+			      &evmask,
+			      1,
+			      &mods);
+	} else {
+		XIUngrabButton (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
+				deviceid,
+				XIAnyButton,
+		                GDK_WINDOW_XID (root),
+				1, &mods);
+	}
+}
+
+void
+grab_button (int      deviceid,
+	     gboolean grab,
+	     GSList  *screens)
+{
+        GSList *l;
+
+        for (l = screens; l; l = l->next) {
+                GdkScreen *screen = l->data;
+
+		grab_button_real (deviceid,
+				  grab,
+				  gdk_screen_get_root_window (screen));
+        }
+}
diff -up gnome-settings-daemon-2.28.2/plugins/common/gsd-keygrab.h.wacom gnome-settings-daemon-2.28.2/plugins/common/gsd-keygrab.h
--- gnome-settings-daemon-2.28.2/plugins/common/gsd-keygrab.h.wacom	2009-05-03 14:15:30.000000000 -0400
+++ gnome-settings-daemon-2.28.2/plugins/common/gsd-keygrab.h	2012-03-05 16:52:15.274475326 -0500
@@ -24,6 +24,7 @@ G_BEGIN_DECLS
 
 #include <glib.h>
 #include <X11/keysym.h>
+#include <X11/extensions/XInput2.h>
 
 typedef struct {
         guint keysym;
@@ -42,6 +43,10 @@ gboolean        match_key       (Key    
 gboolean        key_uses_keycode (const Key *key,
                                   guint keycode);
 
+void            grab_button      (int      deviceid,
+                                  gboolean grab,
+                                  GSList  *screens);
+
 G_END_DECLS
 
 #endif /* __GSD_COMMON_KEYGRAB_H */
diff -up gnome-settings-daemon-2.28.2/plugins/common/Makefile.am.wacom gnome-settings-daemon-2.28.2/plugins/common/Makefile.am
--- gnome-settings-daemon-2.28.2/plugins/common/Makefile.am.wacom	2010-03-10 06:38:16.000000000 -0500
+++ gnome-settings-daemon-2.28.2/plugins/common/Makefile.am	2012-03-05 16:52:15.274475326 -0500
@@ -5,7 +5,9 @@ libcommon_la_SOURCES = \
 	eggaccelerators.c	\
 	eggaccelerators.h	\
 	gsd-keygrab.c		\
-	gsd-keygrab.h
+	gsd-keygrab.h		\
+	gsd-input-helper.c	\
+	gsd-input-helper.h
 
 libcommon_la_CPPFLAGS = \
 	$(AM_CPPFLAGS)
diff -up gnome-settings-daemon-2.28.2/plugins/Makefile.am.wacom gnome-settings-daemon-2.28.2/plugins/Makefile.am
--- gnome-settings-daemon-2.28.2/plugins/Makefile.am.wacom	2012-03-05 16:52:14.740516131 -0500
+++ gnome-settings-daemon-2.28.2/plugins/Makefile.am	2012-03-05 17:01:47.692471529 -0500
@@ -26,5 +26,11 @@ else
 disabled_plugins += smartcard
 endif
 
+if TABLET_SUPPORT
+enabled_plugins += wacom
+else
+disabled_plugins += wacom
+endif
+
 SUBDIRS = common $(enabled_plugins)
 DIST_SUBDIRS = $(SUBDIRS) $(disabled_plugins)
diff -U0 gnome-settings-daemon-2.28.2/plugins/wacom/ChangeLog.wacom gnome-settings-daemon-2.28.2/plugins/wacom/ChangeLog
--- gnome-settings-daemon-2.28.2/plugins/wacom/ChangeLog.wacom	2012-03-05 16:52:15.276477586 -0500
+++ gnome-settings-daemon-2.28.2/plugins/wacom/ChangeLog	2012-03-05 16:52:15.276477586 -0500
@@ -0,0 +1,871 @@
+commit 21d22919e5a1b156444da2460a351dee35801c37
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Mon Mar 5 10:21:46 2012 +0100
+
+    Report an error on partial XRANDR, use more user friendly name for monitors.
+
+commit 2ba723b717d5df115a98924c54cc3b61eedfeab7
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Mon Mar 5 10:09:21 2012 +0100
+
+    Add new warper functions for Xrandr to detect NVidia's "default" monitor (logic from Peter Hutterer's xorg/app/xinput/src/transform.c)
+
+commit c9e986c0d5cd62aba18e24c6e58e6225b13d2fca
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Fri Mar 2 10:03:50 2012 +0100
+
+    Fix schema beaking treeview in gnome-control-center
+
+commit 4409f7b63005fe6f6d09b1ee10bed040ce54be0d
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Thu Mar 1 19:25:19 2012 +0100
+
+    Add gsd_rr_output_info_get_name() and gsd_rr_output_info_get_display_name() to use with gnome-control-center
+
+commit 3b8e49205e100a27b3da037d9c9d889825310b4d
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Thu Mar 1 16:37:24 2012 +0100
+
+    Fix a couple of bugs with RR helpers
+
+commit 3d9956e19582764bb3d270826c811a6a73f9f9b8
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Thu Mar 1 15:05:41 2012 +0100
+
+    Missed one field
+
+commit cc8bb44bb56ec6423c60355d7073535cafd9904d
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Thu Mar 1 14:45:33 2012 +0100
+
+    Modify the RR helpers to support non-Xrandr setup
+
+commit 45e1c5954a2204cd8545cce345675f7af4cdaac1
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Thu Mar 1 10:46:54 2012 +0100
+
+    Check sync status with upstream code
+
+commit 95308a7c3cc241a2598dc945563fbb6ece1dcc4d
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Thu Mar 1 10:32:42 2012 +0100
+
+    Backport commit 66fb80a745b2b120daf18ba70fa99e3e398af0e6
+    
+    wacom: Remove outdated FIXME
+
+commit ed47ab602173b3bcef09919a645cf0a03a6b517d
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Thu Mar 1 10:31:02 2012 +0100
+
+    Backport commit a1d2b35b2c3c15998f2fe33a70573579c87f6f6d
+    
+    wacom: Use current Group to generate keys
+    
+    If you had uk and fr defined as layouts, you'd want Ctrl+Z to still
+    generate Ctrl+Z when using the French layout.
+
+commit 4f05cbd32f051900dbeb9589695708de60a711fc
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Thu Mar 1 10:23:17 2012 +0100
+
+    Backport commit 44558060cf39e5240917c7ca0c0a42c617a93e1f
+    
+    wacom: Add better key generation debug output
+
+commit f7c213fd160c9de69bcd623ad90c1202a78b77d3
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Wed Feb 29 14:46:23 2012 +0100
+
+    Add custom elevator action to schema
+
+commit b3581228c8239cd6836b0133f82c10a8b7e7a978
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Wed Feb 29 14:35:16 2012 +0100
+
+    Constify the array of const char *
+
+commit 1565dd29368c11eef02f9563089b57ae105419c5
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Wed Feb 29 14:07:11 2012 +0100
+
+    Fix possible leak
+
+commit 4ac5ab2c6f0544b5ace2887eb38fd8a4edb76248
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Wed Feb 29 14:06:40 2012 +0100
+
+    Ad more helper functions to use in gnome-control-center-wacom
+
+commit 05c0f2744b60269fe08940d6dc7d4db55d70ea35
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 28 16:11:58 2012 +0100
+
+    Backport commit 0018c53566bbb4d33b77cdf5b55d37d7d946b821
+    
+    wacom: Handle wrongly sized arrays
+    
+    For the elevator shortcut keys.
+
+commit 97276ea55d1c298e53832f399e3221e36871d18d
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 28 16:09:18 2012 +0100
+
+    Backport commit 99fc152af887dcf2ad0710dbcec419324622d361
+    
+    wacom: Implement custom action for elevator buttons
+
+commit 94f16127e50ca91948b2fcedb97135c9b57e606d
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 28 16:00:49 2012 +0100
+
+    Backport commit eec974481a55b2f8dcdcf84ada1e2bec1d8f9557
+    
+    wacom: The index for buttons starts at 1, not zero
+    
+    We start at "mode 1" like the descriptions.
+
+commit 29b88bbb8e0ac40addc12ee51e513f5cd357ef2b
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 28 15:59:44 2012 +0100
+
+    Backport commit 0ebf8e5ac0e148069e1048508a232161fd2188c5
+    
+    wacom: Clean memory leak
+
+commit 3ee7bd0229428b3bee1f18a1e4961851ca662ef0
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 28 15:56:14 2012 +0100
+
+    Backport commit 8f3d87e638ff3e77e04d8cb17ce49974119a3e5f
+    
+    wacom: Remove the "index" parameter to _get_button()
+    
+    GsdWacomDevice already knows the current index, and the
+    caller has no way of knowing it. This also returns the correct
+    button depending on the mode.
+
+commit 299e98557467af3120366478dd1fd7811bba7862
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 28 15:49:49 2012 +0100
+
+    Backport commit 521725fb2a89708af1be86aef15f83f5598cc6d9
+    
+    wacom: Only switch mode on key release
+    
+    Otherwise we'll skip modes 2-by-2.
+
+commit b8cd034291630582793195f101a62ff5485c7b93
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 28 15:48:12 2012 +0100
+
+    Backport commit 4d246750ec52ae3cfd1beee32b3556a138c72519
+    
+    wacom: Implement basic mode switching
+    
+    Though the buttons still won't change behaviour.
+
+commit 4d7fd26284100aae8c75ddfa040b6488e1e79405
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 28 15:45:41 2012 +0100
+
+    Backport commit adbacf26d741d75b4a0a1001430ca5a52ec9126e
+    
+    wacom: Reset the LEDs on startup
+    
+    Even if set_led() isn't implemented yet.
+
+commit 9a23526f1056be47081f0a9584b02630a3c9ab7a
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 28 15:43:30 2012 +0100
+
+    Backport commit a3b3a1f97251b3402807044918b67f9c0810a47b
+    
+    wacom: Add function to set the next mode
+    
+    And return the new mode index. This means that the g-s-d wacom
+    manager doesn't need to track the state of each mode for each
+    tablet itself.
+
+commit 1a692badd98ed2f212a1d22d9589cf33b2e99e96
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 28 15:40:38 2012 +0100
+
+    Backport commit bca340de23c309b46eb2e7a78dc930720ad37c71
+    
+    wacom: Track the current mode and number of modes
+    
+    For each different mode group.
+
+commit f81c421db23a10889ecb9c4f65d30ed2bc0b085b
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 28 15:37:02 2012 +0100
+
+    Backport commit b3378c1974a31549f804abc5e69616eac7b60202
+    
+    wacom: Add stub for setting the current LED
+
+commit 31324a03c02a6fe96c698787ef3fb1318586a6d0
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 28 15:34:56 2012 +0100
+
+    Backport commit f948ba063e4e7fe750d83ce6fe62095556cb6c66
+    
+    wacom: Simplify gsd_wacom_device_add_buttons_dir()
+
+commit 870f6d4111d3471af697296dbe7f8057b7758e86
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 28 15:30:17 2012 +0100
+
+    Backport commit 63f3d53f7fce38205a5f963e82bf631a971b5c10
+    
+    wacom: Add index parameter to _get_button()
+
+commit e45c475069a250a6a6251d04737568223db6b052
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 28 15:20:01 2012 +0100
+
+    Backport commit af1aa4ec40b47075e50b6015ef78ae5565da70cc
+    
+    wacom: Fix touchring button mapping
+    
+    Not sure why this didn't work as expected, possibly a change
+    of behaviour with the newest Wacom driver.
+
+commit c34618d23e6584dcb6ef1926ee77d8d8add367c4
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 28 15:18:26 2012 +0100
+
+    Backport commit ad6cd3cf1acdd2aedd1851101538006db05a0b1e
+    
+    wacom: Remove extraneous debug
+
+commit 0f13978be802432cc40568e8f70c4eaa2f1ce300
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 28 15:16:38 2012 +0100
+
+    Backport commit 389276ef566342c3c61547326c070a0d6914622a
+    
+    wacom: Make touch devices insensitve to KEY_IS_ABSOLUTE changes
+    
+    Pen devices are typically used in absolute mode, while touch
+    devices are used in relative mode. However, the tracking mode
+    of *both* currently depend on the value of KEY_IS_ABSOLUTE.
+    If a preference is set for absolute or relative it will be
+    applied to both devices.
+    
+    This patch has touch devices ignore changes to KEY_IS_ABSOLUTE.
+    Ideally it would be nice to have this key available independently
+    for both pen and touch devices at some point in the future.
+    
+    https://bugzilla.gnome.org/show_bug.cgi?id=670655
+
+commit 957bda756b6df0c46922bcc16fc998607a9a748c
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 28 15:14:35 2012 +0100
+
+    Backport commit 1d1c460876ddf3c1d14f53904b0ec6397c2f58cf
+    
+    wacom: Only support 0.13 wacom for touchring resets
+    
+    The 0.13 driver release actually supports the 2nd touchring, earlier
+    versions didn't.
+
+commit 79f9b6372898b08632608225df9cae86391d48fb
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 28 15:06:46 2012 +0100
+
+    Backport commit 22667fd6a9864967d403bbd79e07ac0ab4b1333f
+    
+    wacom: Document hashtable contents
+
+commit 50b46e1c9e955f61a33033bb570b326d7438022b
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 28 15:04:41 2012 +0100
+
+    Backport commit 7e8288ac1bd43149b79d7cb9f27b6242addf2385
+    
+    wacom: Separate out key emission
+
+commit 68cbd20675dd505e60a6c96ebced5ce50f55171f
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 28 15:04:17 2012 +0100
+
+    Typo
+
+commit 197c6f4eeae6d25462a1bd6388c78459b886a841
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 28 14:48:59 2012 +0100
+
+    Backport commit 37d1dc6825bc32a5ac88cc9396c0a754667c2999
+    
+    wacom: Remove unused XDevice variable
+
+commit b3e71969b0f93565ed107b2914b59fda2740ff17
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 28 14:44:28 2012 +0100
+
+    Backport commit 8530df68d94dc9cd37d87c37444b725bca8eb926
+    
+    wacom: Fix possible double-event generation
+    
+    Generate key press on button press, and key release on button
+    release. Also make sure to use the non-XI XTest functions, to
+    avoid keys not latching as expected.
+    
+    See:
+    https://bugzilla.gnome.org/show_bug.cgi?id=670688
+    https://bugs.freedesktop.org/show_bug.cgi?id=46522
+
+commit eef41544fb286d7fc03dca6ee2f4941a830ed244
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 28 14:39:40 2012 +0100
+
+    Fix indentation and trailing spaces
+
+commit 3d1e0a0e961b18a67be832dcec61e83bfb9faa06
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 28 14:33:21 2012 +0100
+
+    Revert
+
+commit 19a73d81033a4d88f2019b47d70e0fd6a604e62d
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 28 14:31:12 2012 +0100
+
+    Fix indentation and white spaces
+
+commit e8ad34dde974b36df3c361716b3c8ebbdea16543
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 28 14:25:50 2012 +0100
+
+    Backport commit c8d37695cb6fd63b15faafc04c81869ee1378cef
+    
+    wacom: Add index to mode buttons
+
+commit f008390397c2b5d746d74c0862edb19ef7efd9c2
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 28 14:23:36 2012 +0100
+
+    Backport commit 27d06e4ea76b6249762e48ed2480354d85315dad
+    
+    wacom: Add more debug for received events
+
+commit 65b43bf51f39db325315651b571a478fc7ce47b3
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 28 14:15:00 2012 +0100
+
+    Backport commit 795db1b0deaea2188b282d8b03f81aa1439d6621
+    
+    wacom: Micro-optimise sending modifiers
+
+commit 27414624e2e767a9652d092af6d2630c337231a3
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 28 14:13:04 2012 +0100
+
+    Backport commit 16b961084466bffd8d7a106256084bb4b26d07e5
+    
+    wacom: Print index for mode buttons
+
+commit 375805755944f8043a0dc5579e472e8c017389b8
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 28 14:10:49 2012 +0100
+
+    Backport commit 5dd89a267e7c539e681851017b18261dc2e092f0
+    
+    wacom: Force touchpads to use relative mode
+    
+    https://bugzilla.gnome.org/show_bug.cgi?id=670655
+
+commit 800b37e2de8d2d54a27077fce872637cbdd42ad9
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Mon Feb 27 16:14:57 2012 +0100
+
+    Allow passing -1 as monitor to match to whole screen
+
+commit 7c938583ca3ee24e0dfc89f9e27beec6c2ab9dcb
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Mon Feb 27 16:14:43 2012 +0100
+
+    Clean-up trailing spaces
+
+commit 386eea042a101207d6974631b2053689aaa96ff8
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Mon Feb 27 15:26:53 2012 +0100
+
+    Add API to set GConfValues
+
+commit b1479c86bcbbdf9996314f460ee5846e88367e0c
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Mon Feb 27 14:55:59 2012 +0100
+
+    Fix double free
+
+commit 40407ff8b8697f5fe13f3acd29d3d3de7c81a8b0
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Fri Feb 24 13:55:26 2012 +0100
+
+    Remove extra debug
+
+commit 0eb06a3dac8954d05e71ba298cfa540f14534852
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Thu Feb 23 17:30:58 2012 +0100
+
+    Fix schema missing appropriate key for buttons
+
+commit 90a863886f29a34552126b31112e59f2ad1b0da6
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Thu Feb 23 16:29:32 2012 +0100
+
+    Remove applyto from schema
+
+commit 308ebebe213f50818f65e54d194c5bb046df51a8
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Thu Feb 23 16:07:45 2012 +0100
+
+    Simplify gsd_gconf_get() a bit
+
+commit 7dd8636b8ace62f6dc11101ffdd9ffffbc10c4d6
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Thu Feb 23 15:29:59 2012 +0100
+
+    Move enums and related conversions functions to gsd-wacom-device.[ch] as these will be helpful for g-c-c as well (since we do not have gsd-enums.h in g-s-d for GNOME2)
+
+commit 16aaf6a74f33190771963fdd7e4c5e634977f63a
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Thu Feb 23 10:28:33 2012 +0100
+
+    Backport commit a1d9ab194b3590b9acbfb0db92d0be30ad2df130
+    
+    wacom: Fix typo in error message
+
+commit 0c512e60d1386555cbd8910cd9cf70276ad223fe
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Wed Feb 22 12:03:40 2012 +0100
+
+    Fix gcc warnings
+
+commit a57c8a6c9da211c80a12fe613be689583df90b73
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Wed Feb 22 12:02:43 2012 +0100
+
+    Fix Makefile when build directory is not current directory.
+
+commit 3a7f97d8bacd95e5a404c7268076e376e4f8e091
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Wed Feb 22 11:23:52 2012 +0100
+
+    Remove unused variable
+
+commit 5e4b5ac778d8eb2c28b00c0db641b390965c5347
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Wed Feb 22 09:29:54 2012 +0100
+
+    Remove AC_BUTTON as it *is* definitely defined in Xwacom.h (I must have been on crack yesterday...)
+
+commit cf8aafd052fbd8f122bd0e34be87c6def87cff95
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 21 14:55:25 2012 +0100
+
+    Fix leak of GConfValues.
+
+commit a0a664da15e51ef6f0059a287b92daa66b4637ca
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 21 14:54:11 2012 +0100
+
+    Fix previous backport of clean up last tool filter setup.
+    
+    Do not leak GConfValues.
+
+commit bbba76a2d4f4a168cd173820e68a55837ce62f77
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 21 14:52:33 2012 +0100
+
+    Do not free GConfValue lists as it is "owned" by the GConfValue and will be destroyed when the GConfValue is destroyed.
+    
+    Fixes a nasty memory corruption.
+
+commit 16d51307fb2aab6164fce6a8ee7b3b4dbda9ca69
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 21 12:21:13 2012 +0100
+
+    Backport commit 034c565953f53fc213485b5626b25cf446e144e0
+    
+    wacom: Make list-wacom print the tool name on stylus change
+
+commit 386decb4253beed53296f95ff6fba6d708044803
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 21 12:20:03 2012 +0100
+
+    Backport commit da080b94bc2af338aa17090aa0b92a60352cab7e
+    
+    wacom: Clean up last tool filter setup
+
+commit b5a26f04ca86a39af892f767a87d968d4fc5a349
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 21 12:16:11 2012 +0100
+
+    Backport commit cbdef2351c10f509c19a639a830342ae71833801
+    
+    wacom: Use the constants from the Wacom driver directly
+    
+    Rather than copy/pasting them.
+    
+    Note: AC_BUTTON is missing from Xwacom.h in in current linuxwacom-0.13
+
+commit 6f5c4c30bdc7575e0be2a73ee1eb3f184aa8ff7b
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 21 12:09:20 2012 +0100
+
+    Ugly hack to associate the key with the schema for wacom devices.
+
+commit 41f6086f82878a3cbfdd13ba65ef7b7adddf36a2
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Mon Feb 20 19:03:21 2012 +0100
+
+    Cleanup, move GConf notity add to gsd-wacom-manager to avoid side effects with loading settings from GConf schema when aadding new (unknown) devices.
+
+commit a40c81ca1fefb05aa6964620a3bdabbcb7cf5745
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Mon Feb 20 13:19:04 2012 +0100
+
+    Cleanup (cont'd)
+
+commit c6688d4400a883c64637356bdca6b8b8f92f0845
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Mon Feb 20 11:38:11 2012 +0100
+
+    Cleanup
+
+commit 36c1f4501c9e85bc7852e88d383b9e99ae219c24
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Mon Feb 20 10:18:08 2012 +0100
+
+    Load preload GConf settings recursiveley for each device.
+
+commit a6986dcd32c3373e317eef9a5916ea3a3dda4951
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Mon Feb 20 09:55:46 2012 +0100
+
+    Backport commit b8925192bd05c1a6b0f5868cc69b38cddd83243a
+    
+    wacom: Don't call out to xsetwacom
+    
+    To reset the pad buttons, set the action properties ourselves instead.
+    
+    With help from Peter Hutterer.
+
+commit 0cf5a1a673f1fb51d6eceb44ae2593bc571f4f7d
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Fri Feb 17 16:45:59 2012 +0100
+
+    Improve header files for helpers functions
+
+commit ee91c6edd695417de4c7b6011f36b766676ff484
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Fri Feb 17 15:27:16 2012 +0100
+
+    Fix custom-action key in schema
+
+commit 6ac027dde2298b7e3f0510a8dca192f9d26f1c6e
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Fri Feb 17 14:49:19 2012 +0100
+
+    Move backport helper functions to a separate lib.
+
+commit 6462e580ed0ac55a5bfbe82cc1848791fe7de8d8
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Fri Feb 17 14:32:15 2012 +0100
+
+    Backport commit b4d1291cf40fceecc8ac199dcd17d716b5191aa9
+    
+    wacom: Check error path for display-mapping
+
+commit 19f83dc66d1009bb3c49cab15a08ff58191a6afb
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Fri Feb 17 14:27:48 2012 +0100
+
+    Backport commit eba2d233e609abdd4bbdab066a655e3634efd81c
+    
+    wacom: Less output with default display-mapping
+
+commit 79627f3008864ceeb8f6d4f2639b41e9b84002bd
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Fri Feb 17 14:20:16 2012 +0100
+
+    Backport commit 1e24c0faa7027f7eea4fc4ed58ff1009e6ca0e09
+    
+    wacom: Better check for tablet button mapping errors
+
+commit 6a83aa0f2eba360573f41dcb01373043f699facb
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Fri Feb 17 14:16:59 2012 +0100
+
+    Backport commit 32766032eea685aa2121fe99fff9198f1f17ae7f
+    
+    wacom: Make warnings statements debug ones
+
+commit 956778580c6e0eb3780f0d56344460fa3713c797
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Fri Feb 17 14:14:53 2012 +0100
+
+    Backport commit f69058e3f6f1bcf56bfa08a618d005484219156e
+    
+    wacom: Remove extraneous debug
+
+commit 7cd7149cf6eb1af4bd2091aa70831d4571b4ebd5
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Fri Feb 17 14:12:13 2012 +0100
+
+    Backport commit fa5958fd261ef2c97d5722fa70cfcd33eb7be0c0
+    
+    wacom: Use XTest to send out custom bindings
+    
+    https://bugzilla.gnome.org/show_bug.cgi?id=670096
+
+commit e977eba8bc7bb1570cfb74e754eef3eae29879eb
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Fri Feb 17 12:27:23 2012 +0100
+
+    Backport commit dfd73d6c2201b2a02ed01d35af8f483c73c06736
+    
+    wacom: Add more FIXMEs for some button types
+
+commit b1b68b567b2a121154e45b2a7eb073382bb64f39
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Fri Feb 17 12:07:51 2012 +0100
+
+    Backport 8c41b6a1e80c518af569bd6bc7a01a643c81804b
+    
+    wacom: Do something on button press and release
+
+commit d2e61b3649a46bd0d4c64ced707527d7a2fba60d
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Fri Feb 17 12:06:20 2012 +0100
+
+    Backport commit f5f957ff982bbe693b4b9c50171778f9807ee4b0
+    
+    wacom: Implement "none" action-type
+    
+    That was hard...
+
+commit 609f4ff28c302bce4d3bf9c67885cef2b68c0a08
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Fri Feb 17 11:55:10 2012 +0100
+
+    Backport commit 908127d6f2a8bd64bec5c3d6f75f435f48bbb5dd
+    
+    wacom: Add define for maximum group_id value
+
+commit a556396dbb525b5656ded06947ccfa2a70819c02
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Fri Feb 17 11:52:33 2012 +0100
+
+    Backport commit be746e57e49cdb376c1ee0416b976a66e55f33b2
+    
+    wacom: Implement capturing all the pad buttons
+    
+    We just need to make them do things now.
+
+commit 7dc32424ca233bb815c72fb8056d25eb5086b20d
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Fri Feb 17 10:56:21 2012 +0100
+
+    Backport commit b72a36fd344253de0a6a8a647481820c3363c7fb
+    
+    wacom: Add mouse button to physical button mapping
+    
+    From the mouse button number to the physical name of the button,
+    with its type, and what we should do with it, in one easy function.
+
+commit 79d93d4eb287b9c64cdc2dd4ece6fb8ad165cf08
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Fri Feb 17 10:53:09 2012 +0100
+
+    Backport commit 33d62c78c640c7316ced47ecbb76a4420f45f7b4
+    
+    wacom: Don't prefix IDs with location
+    
+    This is not useful in the ID itself, only in the description.
+
+commit 0f8b5b362f849949c97b9cdaa6b7a72bd10bf65a
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Fri Feb 17 10:49:08 2012 +0100
+
+    Backport commit d4a59712135f2a5202dc98d07b879d1f1101856d
+    
+    wacom: Split getting the device ID of a device
+
+commit 6a773d6e692650b7096e0aed370833d938e730b1
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Fri Feb 17 10:38:06 2012 +0100
+
+    Backport commit 3e94c6e03316aa1c92f2a1ef4e8fada7d3f27a73
+    
+    wacom: Add public 'gsd_wacom_device_set_display' function
+    
+    Provides a way for callers to set the 'display' key, without
+    requring them to know details of the how its stored. All that
+    is required is the monitor number.
+    
+    https://bugzilla.gnome.org/show_bug.cgi?id=668546
+
+commit effb8996e312ffdf6f482759b7643b7a41097ebf
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Fri Feb 17 10:16:19 2012 +0100
+
+    Backport commit a9ed268416e8a7de857a4c521425a47916092a48
+    
+    wacom: Add settings listing to list-wacom
+
+commit ea27b7b2d1ff527468385bac92fb62df15a732a1
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Fri Feb 17 09:53:17 2012 +0100
+
+    Backport commit 9304313a0a6faa6d4904047d01b95c0620e68b9c
+    
+    wacom: Add settings member for tablet buttons
+
+commit 063a93107848b20244f27ff6e452e27f10a86234
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Fri Feb 17 09:26:39 2012 +0100
+
+    Reindentation
+
+commit c2077e85a21df72274bcb397c1222d736ad7527e
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Fri Feb 17 09:12:35 2012 +0100
+
+    Backport commit ef84a3c3a9acfc7094d10b665f644378daafe89f
+    
+    wacom: Remove unused constant
+
+commit 0434749c0c003dc13fdcf9a8aaf25d1b7dee2f89
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Fri Feb 17 09:11:01 2012 +0100
+
+    Backport commit f0e527b0e816e55a43d386f297fc0ac54dfe96f3
+    
+    wacom: Handle arbitrary number of buttons
+    
+    Rather than the hardcoded number we used to use.
+
+commit 4e191d808651f979d25a70b30a9d0cbe8e31493d
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Fri Feb 17 09:07:58 2012 +0100
+
+    Update to upstream commit 79b0258366c3b4b988eb585e1dae49317f6af7a8
+    
+    wacom: Add "Touch" device type
+    
+    This would allow touch to be rotated as needed when the rest of the tablet is.
+
+commit b706430cc36d9bab526c118508706dfe81fd740a
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Thu Feb 16 17:18:03 2012 +0100
+
+    Fix a couple of crashes
+
+commit c413f9f619db475b9861d3e09bfa519534c56637
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Thu Feb 16 14:45:15 2012 +0100
+
+    gnome-settings-daemon builds, test-wacom works, list-wacom as well.
+
+commit 8e15c540ec529cd530f3bfcd08e009f765de9fbb
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Wed Feb 15 18:53:07 2012 +0100
+
+    Fix GnomeOutputInfo not being a g_object apparently in GNOME2,
+    Add more Gconf-ization
+
+commit bbad6c3e20614b438dea4ace392ad3086e4b127e
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Wed Feb 15 17:27:04 2012 +0100
+
+    test-wacom seems to be working now.
+
+commit c7227b878571b7627ead154335f547cfd8dfaf5c
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 14 17:53:04 2012 +0100
+
+    Fix build, calling the gsd plugin libwacom while depending on libwacom, the lib is *not* a good idea, generally speaking...
+    Note: this is still WIP, it won't finish the build yet.
+
+commit 7263eec3444b2575d45f34865223868da512da65
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 14 14:48:46 2012 +0100
+
+    GsdDeviceManager now passes XDeviceInfo directly in signals so it's much more useful for our use case
+
+commit 23f65afa33385577f0d620f40ad89fc199075630
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 14 13:25:25 2012 +0100
+
+    Fix GsdDeviceManager and add a simple test program to validate
+
+commit ae1de22b37dda6f28a6527e7d4aceb43968f0d20
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Mon Feb 13 16:59:37 2012 +0100
+
+    Add a simple GsdDeviceManager (unfinished) to mimic GdkDeviceManager
+
+commit eb12ce1f8b646a4e339bb048a0407174df3e69cc
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Mon Feb 13 10:13:27 2012 +0100
+
+    Backport GSettings to GConf (cont.)
+
+commit 6cfc786d849e51fc94a59f8c270da85f0a24ee9a
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Fri Feb 10 11:01:48 2012 +0100
+
+    Update schema for tablet button configuration
+
+commit c68ea5d3a2636758db32498164d97cabef0e4ff5
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Wed Feb 8 17:59:31 2012 +0100
+
+    Fix build after merge
+
+commit 86f1fbe731d713133bcc97f3b4ad065b5489b79a
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Wed Feb 8 17:32:35 2012 +0100
+
+    Update libwacom minimum version required
+
+commit 3b28b7a0c25bc0933553aa3188000c4ae4ae7cc4
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Wed Feb 8 16:58:32 2012 +0100
+
+    Backport recent changes from upstream wrt tablet buttons
+
+commit ca0f882f641904af0c5c6bc69bb47c6bfa09c20c
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Wed Feb 8 15:28:32 2012 +0100
+
+    Start backport
+
+commit 576f29023f2d0f388d40819297b958e77a76a52f
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Wed Feb 8 15:26:39 2012 +0100
+
+    Add helper sources for GSettings to GConf backport and GnomeRROuput* compatibility
+
+commit 99dcfc2adfa478942ff7181dbd7a0dae5ec45b03
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Wed Feb 8 09:53:55 2012 +0100
+
+    Backport input helpers, remove unused portions of code in g-s-d 2.28
+
+commit 925433ac22230ac0a797da3b544d2441eded6fe8
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Wed Feb 8 09:50:11 2012 +0100
+
+    Update build files
+
+commit fe0e30a22b164d7612a320f7d4bdb38b16c6402d
+Author: Olivier Fourdan <ofourdan@redhat.com>
+Date:   Tue Feb 7 17:52:32 2012 +0100
+
+    Init git repo containing gnome-2.28 branch of g-s-d with upstream GNOME 3 code added for Wacom support
diff -up gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-device.c.wacom gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-device.c
--- gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-device.c.wacom	2012-03-05 16:52:15.278454149 -0500
+++ gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-device.c	2012-03-05 16:52:15.278454149 -0500
@@ -0,0 +1,1923 @@
+/*
+ * Copyright (C) 2011 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Author: Bastien Nocera <hadess@hadess.net>
+ *
+ */
+
+#include "config.h"
+
+#include <glib.h>
+#include <glib/gi18n-lib.h>
+#include <gtk/gtk.h>
+#include <gdk/gdk.h>
+#include <gdk/gdkx.h>
+#include <X11/Xatom.h>
+#define GNOME_DESKTOP_USE_UNSTABLE_API
+#include <libgnomeui/gnome-rr.h>
+#include <libgnomeui/gnome-rr-config.h>
+
+#include <libwacom/libwacom.h>
+#include <X11/extensions/XInput2.h>
+
+#include "gsd-wacom-device.h"
+#include "gsd-input-helper.h"
+#include "gsd-wacom-gconf-helpers.h"
+#include "gsd-wacom-rr-helpers.h"
+#include "gsd-wacom-devmanager-helpers.h"
+
+#define GSD_WACOM_STYLUS_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GSD_TYPE_WACOM_STYLUS, GsdWacomStylusPrivate))
+
+#define WACOM_DEVICE_CONFIG_BASE "/desktop/gnome/peripherals/wacom"
+#define WACOM_TABLET_SCHEMA	 "/schemas/desktop/gnome/peripherals/wacom"
+#define WACOM_STYLUS_SCHEMA	 "/schemas/desktop/gnome/peripherals/wacom/stylus"
+#define WACOM_ERASER_SCHEMA	 "/schemas/desktop/gnome/peripherals/wacom/eraser"
+#define WACOM_BUTTON_SCHEMA	 "/schemas/desktop/gnome/peripherals/wacom/tablet-button"
+
+static WacomDeviceDatabase *db = NULL;
+
+struct GsdWacomStylusPrivate
+{
+    GsdWacomDevice *device;
+
+    int id;
+    WacomStylusType type;
+    char *name;
+    const char *icon_name;
+    char *settings_path;
+    char *schemas_path;
+    gboolean has_eraser;
+    int num_buttons;
+};
+
+static void     gsd_wacom_stylus_class_init	(GsdWacomStylusClass	*klass);
+static void     gsd_wacom_stylus_init		(GsdWacomStylus		*wacom_stylus);
+static void     gsd_wacom_stylus_finalize	(GObject		*object);
+
+G_DEFINE_TYPE (GsdWacomStylus, gsd_wacom_stylus, G_TYPE_OBJECT)
+
+static void
+gsd_wacom_stylus_class_init (GsdWacomStylusClass *klass)
+{
+	GObjectClass   *object_class = G_OBJECT_CLASS (klass);
+
+	object_class->finalize = gsd_wacom_stylus_finalize;
+
+	g_type_class_add_private (klass, sizeof (GsdWacomStylusPrivate));
+}
+
+static void
+gsd_wacom_stylus_init (GsdWacomStylus *stylus)
+{
+	stylus->priv = GSD_WACOM_STYLUS_GET_PRIVATE (stylus);
+}
+
+static void
+gsd_wacom_stylus_finalize (GObject *object)
+{
+	GsdWacomStylus *stylus;
+	GsdWacomStylusPrivate *p;
+
+	g_return_if_fail (object != NULL);
+	g_return_if_fail (GSD_IS_WACOM_STYLUS (object));
+
+	stylus = GSD_WACOM_STYLUS (object);
+
+	g_return_if_fail (stylus->priv != NULL);
+
+	p = stylus->priv;
+
+	g_free (p->settings_path);
+	p->settings_path = NULL;
+
+	g_free (p->schemas_path);
+	p->schemas_path = NULL;
+
+	g_free (p->name);
+	p->name = NULL;
+
+	G_OBJECT_CLASS (gsd_wacom_stylus_parent_class)->finalize (object);
+}
+
+static const char *
+get_icon_name_from_type (WacomStylusType type)
+{
+	switch (type) {
+	case WSTYLUS_INKING:
+	case WSTYLUS_STROKE:
+		/* The stroke pen is the same as the inking pen with
+		 * a different nib */
+		return "wacom-stylus-inking";
+	case WSTYLUS_AIRBRUSH:
+		return "wacom-stylus-airbrush";
+	case WSTYLUS_MARKER:
+		return "wacom-stylus-art-pen";
+	case WSTYLUS_CLASSIC:
+		return "wacom-stylus-classic";
+	default:
+		return "wacom-stylus";
+	}
+}
+
+static GsdWacomStylus *
+gsd_wacom_stylus_new (GsdWacomDevice	*device,
+		      const WacomStylus	*wstylus,
+		      char		*settings_path,
+		      char		*schemas_path)
+{
+	GsdWacomStylus *stylus;
+
+	g_return_val_if_fail (wstylus != NULL, NULL);
+
+	stylus = GSD_WACOM_STYLUS (g_object_new (GSD_TYPE_WACOM_STYLUS,
+						 NULL));
+	stylus->priv->device = device;
+	stylus->priv->id = libwacom_stylus_get_id (wstylus);
+	stylus->priv->name = g_strdup (libwacom_stylus_get_name (wstylus));
+	stylus->priv->settings_path = g_strdup (settings_path);
+	stylus->priv->schemas_path = g_strdup (schemas_path);
+	stylus->priv->type = libwacom_stylus_get_type (wstylus);
+	stylus->priv->icon_name = get_icon_name_from_type (stylus->priv->type);
+	stylus->priv->has_eraser = libwacom_stylus_has_eraser (wstylus);
+	stylus->priv->num_buttons = libwacom_stylus_get_num_buttons (wstylus);
+
+	return stylus;
+}
+
+const char *
+gsd_wacom_stylus_get_settings_path (GsdWacomStylus *stylus)
+{
+	g_return_val_if_fail (GSD_IS_WACOM_STYLUS (stylus), NULL);
+
+	return stylus->priv->settings_path;
+}
+
+const char *
+gsd_wacom_stylus_get_schemas_path (GsdWacomStylus *stylus)
+{
+	g_return_val_if_fail (GSD_IS_WACOM_STYLUS (stylus), NULL);
+
+	return stylus->priv->schemas_path;
+}
+
+const char *
+gsd_wacom_stylus_get_name (GsdWacomStylus *stylus)
+{
+	g_return_val_if_fail (GSD_IS_WACOM_STYLUS (stylus), NULL);
+
+	return stylus->priv->name;
+}
+
+const char *
+gsd_wacom_stylus_get_icon_name (GsdWacomStylus *stylus)
+{
+	g_return_val_if_fail (GSD_IS_WACOM_STYLUS (stylus), NULL);
+
+	return stylus->priv->icon_name;
+}
+
+GsdWacomDevice *
+gsd_wacom_stylus_get_device (GsdWacomStylus *stylus)
+{
+	g_return_val_if_fail (GSD_IS_WACOM_STYLUS (stylus), NULL);
+
+	return stylus->priv->device;
+}
+
+gboolean
+gsd_wacom_stylus_get_has_eraser (GsdWacomStylus *stylus)
+{
+	g_return_val_if_fail (GSD_IS_WACOM_STYLUS (stylus), FALSE);
+
+	return stylus->priv->has_eraser;
+}
+
+guint
+gsd_wacom_stylus_get_num_buttons (GsdWacomStylus *stylus)
+{
+	g_return_val_if_fail (GSD_IS_WACOM_STYLUS (stylus), -1);
+
+	return stylus->priv->num_buttons;
+}
+
+int
+gsd_wacom_stylus_get_id (GsdWacomStylus *stylus)
+{
+	g_return_val_if_fail (GSD_IS_WACOM_STYLUS (stylus), -1);
+
+	return stylus->priv->id;
+}
+
+
+GsdWacomStylusType
+gsd_wacom_stylus_get_stylus_type (GsdWacomStylus *stylus)
+{
+	g_return_val_if_fail (GSD_IS_WACOM_STYLUS (stylus), WACOM_STYLUS_TYPE_UNKNOWN);
+
+	switch (stylus->priv->type) {
+	case WSTYLUS_UNKNOWN:
+		return WACOM_STYLUS_TYPE_UNKNOWN;
+	case WSTYLUS_GENERAL:
+		return WACOM_STYLUS_TYPE_GENERAL;
+	case WSTYLUS_INKING:
+		return WACOM_STYLUS_TYPE_INKING;
+	case WSTYLUS_AIRBRUSH:
+		return WACOM_STYLUS_TYPE_AIRBRUSH;
+	case WSTYLUS_CLASSIC:
+		return WACOM_STYLUS_TYPE_CLASSIC;
+	case WSTYLUS_MARKER:
+		return WACOM_STYLUS_TYPE_MARKER;
+	case WSTYLUS_STROKE:
+		return WACOM_STYLUS_TYPE_STROKE;
+	case WSTYLUS_PUCK:
+		return WACOM_STYLUS_TYPE_PUCK;
+	default:
+		g_assert_not_reached ();
+	}
+
+	return WACOM_STYLUS_TYPE_UNKNOWN;
+}
+
+/* Tablet buttons */
+static GsdWacomTabletButton *
+gsd_wacom_tablet_button_new (const char		      *name,
+			     const char		      *id,
+			     const char		      *settings_path,
+			     GsdWacomTabletButtonType  type,
+			     int		       group_id,
+			     int		       idx)
+{
+	GsdWacomTabletButton *ret;
+
+	ret = g_new0 (GsdWacomTabletButton, 1);
+	ret->name = g_strdup (name);
+	ret->id = g_strdup (id);
+	if (type != WACOM_TABLET_BUTTON_TYPE_HARDCODED) {
+		ret->schemas_path =  g_strdup (WACOM_BUTTON_SCHEMA);
+		ret->settings_path = gsd_gconf_build_path (settings_path, id);
+	}
+	ret->group_id = group_id;
+	ret->idx = idx;
+	ret->type = type;
+
+	return ret;
+}
+
+void
+gsd_wacom_tablet_button_free (GsdWacomTabletButton *button)
+{
+	g_return_if_fail (button != NULL);
+
+	g_free (button->settings_path);
+	g_free (button->schemas_path);
+	g_free (button->name);
+	g_free (button->id);
+	g_free (button);
+}
+
+GsdWacomTabletButton *
+gsd_wacom_tablet_button_copy (GsdWacomTabletButton *button)
+{
+	GsdWacomTabletButton *ret;
+
+	g_return_val_if_fail (button != NULL, NULL);
+
+	ret = g_new0 (GsdWacomTabletButton, 1);
+	ret->name = g_strdup (button->name);
+	ret->settings_path = g_strdup (button->settings_path);
+	ret->schemas_path = g_strdup (button->schemas_path);
+	ret->id = button->id;
+	ret->type = button->type;
+	ret->group_id = button->group_id;
+
+	return ret;
+}
+
+const char *
+gsd_wacom_tablet_button_get_settings_path (GsdWacomTabletButton *button)
+{
+	g_return_val_if_fail (button != NULL, NULL);
+
+	return button->settings_path;
+}
+
+const char *
+gsd_wacom_tablet_button_get_schemas_path (GsdWacomTabletButton *button)
+{
+	g_return_val_if_fail (button != NULL, NULL);
+
+	return button->schemas_path;
+}
+
+#define GSD_WACOM_DEVICE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GSD_TYPE_WACOM_DEVICE, GsdWacomDevicePrivate))
+
+/* we support two types of settings:
+ * Tablet-wide settings: applied to each tool on the tablet. e.g. rotation
+ * Tool-specific settings: applied to one tool only.
+ */
+#define SETTINGS_WACOM_DIR	 "org.gnome.settings-daemon.peripherals.wacom"
+#define SETTINGS_STYLUS_DIR	"stylus"
+#define SETTINGS_ERASER_DIR	"eraser"
+
+struct GsdWacomDevicePrivate
+{
+	XDeviceInfo *device_info;
+	int device_id;
+	int opcode;
+
+	GsdWacomDeviceType type;
+	char *name;
+	char *icon_name;
+	char *tool_name;
+	gboolean reversible;
+	gboolean is_screen_tablet;
+	GList *styli;
+	GsdWacomStylus *last_stylus;
+	GList *buttons;
+	GHashTable *modes; /* key = int (group), value = int (index) */
+	GHashTable *num_modes; /* key = int (group), value = int (index) */
+	char *settings_path;
+	char *schemas_path;
+};
+
+enum {
+	PROP_0,
+	PROP_DEVICE_INFO,
+	PROP_LAST_STYLUS
+};
+
+static void     gsd_wacom_device_class_init	(GsdWacomDeviceClass	*klass);
+static void     gsd_wacom_device_init		(GsdWacomDevice		*wacom_device);
+static void     gsd_wacom_device_finalize	(GObject		*object);
+
+G_DEFINE_TYPE (GsdWacomDevice, gsd_wacom_device, G_TYPE_OBJECT)
+
+static GdkFilterReturn
+filter_events (XEvent	 *xevent,
+	       GdkEvent       *event,
+	       GsdWacomDevice *device)
+{
+	XIEvent	     *xiev;
+	XIPropertyEvent     *pev;
+	XGenericEventCookie *cookie;
+	char		*name;
+	int		  tool_id;
+
+	/* verify we have a property event */
+	if (xevent->type != GenericEvent)
+		return GDK_FILTER_CONTINUE;
+
+	cookie = &xevent->xcookie;
+	if (cookie->extension != device->priv->opcode)
+		return GDK_FILTER_CONTINUE;
+
+	xiev = (XIEvent *) xevent->xcookie.data;
+
+	if (xiev == NULL)
+		return GDK_FILTER_CONTINUE;
+
+	if (xiev->evtype != XI_PropertyEvent)
+		return GDK_FILTER_CONTINUE;
+
+	pev = (XIPropertyEvent *) xiev;
+
+	/* Is the event for us? */
+	if (pev->deviceid != device->priv->device_id)
+		return GDK_FILTER_CONTINUE;
+
+	name = XGetAtomName (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), pev->property);
+	if (name == NULL ||
+	    g_strcmp0 (name, WACOM_SERIAL_IDS_PROP) != 0) {
+		return GDK_FILTER_CONTINUE;
+	}
+	XFree (name);
+
+	tool_id = xdevice_get_last_tool_id (device->priv->device_id);
+	if (tool_id == -1) {
+		g_warning ("Failed to get value for changed stylus ID on device '%d'", device->priv->device_id);
+		return GDK_FILTER_CONTINUE;
+	}
+	gsd_wacom_device_set_current_stylus (device, tool_id);
+
+	return GDK_FILTER_CONTINUE;
+}
+
+static gboolean
+setup_property_notify (GsdWacomDevice *device)
+{
+	Display *dpy;
+	XIEventMask evmask;
+	int tool_id;
+
+	evmask.deviceid = device->priv->device_id;
+	evmask.mask_len = XIMaskLen (XI_PropertyEvent);
+	evmask.mask = g_malloc0(evmask.mask_len * sizeof(char));
+	XISetMask (evmask.mask, XI_PropertyEvent);
+
+	dpy = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
+	XISelectEvents (dpy, DefaultRootWindow(dpy), &evmask, 1);
+
+	g_free (evmask.mask);
+
+	gdk_window_add_filter (NULL,
+			       (GdkFilterFunc) filter_events,
+			       device);
+
+	tool_id = xdevice_get_last_tool_id (device->priv->device_id);
+	if (tool_id == -1) {
+		g_warning ("Failed to get value for changed stylus ID on device '%d", device->priv->device_id);
+		return TRUE;
+	}
+	gsd_wacom_device_set_current_stylus (device, tool_id);
+
+	return TRUE;
+}
+
+static GsdWacomDeviceType
+get_device_type (XDeviceInfo *dev)
+{
+	GsdWacomDeviceType ret;
+	static Atom stylus, cursor, eraser, pad, touch, prop;
+	XDevice *device;
+	Atom realtype;
+	int realformat;
+	unsigned long nitems, bytes_after;
+	unsigned char *data = NULL;
+	int rc;
+
+	ret = WACOM_TYPE_INVALID;
+
+	if ((dev->use == IsXPointer) || (dev->use == IsXKeyboard))
+		return ret;
+
+	if (!stylus)
+		stylus = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), "STYLUS", False);
+	if (!eraser)
+		eraser = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), "ERASER", False);
+	if (!cursor)
+		cursor = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), "CURSOR", False);
+	if (!pad)
+		pad = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), "PAD", False);
+	if (!touch)
+		touch = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), "TOUCH", False);
+	if (!prop)
+		prop = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), "Wacom Tool Type", False);
+
+	if (dev->type == stylus)
+		ret = WACOM_TYPE_STYLUS;
+	else if (dev->type == eraser)
+		ret = WACOM_TYPE_ERASER;
+	else if (dev->type == cursor)
+		ret = WACOM_TYPE_CURSOR;
+	else if (dev->type == pad)
+		ret = WACOM_TYPE_PAD;
+	else if (dev->type == touch)
+		ret = WACOM_TYPE_TOUCH;
+
+	if (ret == WACOM_TYPE_INVALID)
+		return ret;
+
+	/* There is currently no good way of detecting the driver for a device
+	 * other than checking for a driver-specific property.
+	 * Wacom Tool Type exists on all tools
+	 */
+	gdk_error_trap_push ();
+	device = XOpenDevice (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), dev->id);
+	if (gdk_error_trap_pop () || (device == NULL))
+		return ret;
+
+	gdk_error_trap_push ();
+
+	rc = XGetDeviceProperty (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
+				 device, prop, 0, 1, False,
+				 XA_ATOM, &realtype, &realformat, &nitems,
+				 &bytes_after, &data);
+	if (gdk_error_trap_pop () || rc != Success || realtype == None) {
+		XCloseDevice (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), device);
+		ret = WACOM_TYPE_INVALID;
+	}
+
+	XFree (data);
+
+	return ret;
+}
+
+/* Finds an output which matches the given EDID information. Any NULL
+ * parameter will be interpreted to match any value.
+ */
+static GnomeOutputInfo*
+find_output_by_edid (const gchar *vendor, const gchar *product, const gchar *serial)
+{
+	GError *error = NULL;
+	GnomeRRScreen *rr_screen = NULL;
+	GnomeRRConfig *rr_config = NULL;
+	GnomeOutputInfo **rr_output_info, **outputs;
+	GnomeOutputInfo *retval = NULL;
+
+	rr_screen = gsd_rr_screen_new (gdk_screen_get_default (),
+					 NULL, NULL,
+					 &error);
+	if (rr_screen == NULL) {
+		g_warning ("Failed to create GnomeRRScreen: %s", error->message);
+		g_error_free (error);
+	} else
+		rr_config = gnome_rr_config_new_current (rr_screen);
+
+	/* gsd_rr_config_compat_outputs_get() should return something even if rr_config in NULL */
+	rr_output_info = gsd_rr_config_compat_outputs_get (rr_config);
+
+	for (outputs = rr_output_info; *outputs != NULL; outputs++) {
+		gchar *o_vendor;
+		gchar *o_product;
+		gchar *o_serial;
+		gboolean match;
+
+		o_vendor = g_malloc0 (4);
+		gsd_rr_output_info_get_vendor (*outputs, o_vendor);
+		o_product = g_strdup_printf ("%d", gsd_rr_output_info_get_product (*outputs));
+		o_serial  = g_strdup_printf ("%d", gsd_rr_output_info_get_serial  (*outputs));
+
+		g_debug ("Checking for match between '%s','%s','%s' and '%s','%s','%s'",
+			 vendor, product, serial, o_vendor,o_product,o_serial);
+
+		match = (vendor  == NULL || g_strcmp0 (vendor,  o_vendor)  == 0) && \
+			(product == NULL || g_strcmp0 (product, o_product) == 0) && \
+			(serial  == NULL || g_strcmp0 (serial,  o_serial)  == 0);
+
+		g_free (o_vendor);
+		g_free (o_product);
+		g_free (o_serial);
+
+		if (match) {
+			retval = gsd_rr_compat_output_deep_copy (*outputs);
+			break;
+		}
+	}
+
+	gsd_rr_config_compat_outputs_free (rr_output_info);
+	if (rr_config)
+		gnome_rr_config_free (rr_config);
+	if (rr_screen)
+		gnome_rr_screen_destroy (rr_screen);
+
+	if (retval == NULL)
+		g_debug ("Did not find a matching output for EDID '%s,%s,%s'",
+			 vendor, product, serial);
+
+	return retval;
+}
+
+static GnomeOutputInfo*
+find_output_by_heuristic (GsdWacomDevice *device)
+{
+	GnomeOutputInfo *rr_output_info;
+
+	/* TODO: This heuristic will fail for non-Wacom display
+	 * tablets and may give the wrong result if multiple Wacom
+	 * display tablets are connected.
+	 */
+	rr_output_info = find_output_by_edid("WAC", NULL, NULL);
+	return rr_output_info;
+}
+
+static GnomeOutputInfo*
+find_output_by_display (GsdWacomDevice *device)
+{
+	gsize n;
+	GConfValue *display;
+	gchar **edid;
+	GnomeOutputInfo* info;
+
+	if (device == NULL)
+		return NULL;
+
+	display  = gsd_gconf_get (device->priv->settings_path, device->priv->schemas_path, "display");
+	edid     = gsd_gconf_value_get_strv (display, &n);
+	gconf_value_free (display);
+
+	if (n != 3) {
+		g_critical ("Expected 'display' key to store %d values; got %"G_GSIZE_FORMAT".", 3, n);
+		g_strfreev (edid);
+		return NULL;
+	}
+
+	if (strlen(edid[0]) == 0 || strlen(edid[1]) == 0 || strlen(edid[2]) == 0) {
+		g_strfreev (edid);
+		return NULL;
+	}
+
+	info = find_output_by_edid (edid[0], edid[1], edid[2]);
+	g_strfreev (edid);
+
+	return info;
+}
+
+static GnomeOutputInfo*
+find_output_by_monitor (GdkScreen *screen,
+			int        monitor)
+{
+	GError *error = NULL;
+	GnomeRRScreen *rr_screen = NULL;
+	GnomeRRConfig *rr_config;
+	GnomeOutputInfo **rr_output_infos;
+	GnomeOutputInfo *ret;
+	guint i;
+
+	ret = NULL;
+
+	rr_screen =  gsd_rr_screen_new (gdk_screen_get_default (),
+					 NULL, NULL,
+					 &error);
+	if (rr_screen == NULL) {
+		g_warning ("gnome_rr_screen_new() failed: %s", error->message);
+		g_error_free (error);
+	} else
+		rr_config = gnome_rr_config_new_current (rr_screen);
+
+	/* gsd_rr_config_compat_outputs_get() should return something even if rr_config in NULL */
+	rr_output_infos = gsd_rr_config_compat_outputs_get (rr_config);
+
+	for (i = 0; rr_output_infos[i] != NULL; i++) {
+		GnomeOutputInfo *info;
+		int x, y, w, h;
+
+		info = rr_output_infos[i];
+
+		if (!gsd_rr_output_info_is_active (info))
+			continue;
+
+		gsd_rr_output_info_get_geometry (info, &x, &y, &w, &h);
+		if (monitor == gdk_screen_get_monitor_at_point (screen, x, y)) {
+			ret = gsd_rr_compat_output_deep_copy (info);
+			break;
+		}
+	}
+
+	gsd_rr_config_compat_outputs_free (rr_output_infos);
+	if (rr_config)
+		gnome_rr_config_free (rr_config);
+	if (rr_screen)
+		gnome_rr_screen_destroy (rr_screen);
+
+	if (ret == NULL)
+		g_warning ("No output found for monitor %d.", monitor);
+
+	return ret;
+}
+
+static void
+set_display_by_output (GsdWacomDevice    *device,
+		       GnomeOutputInfo   *rr_output_info)
+{
+	GConfValue  *display;
+	gsize        nvalues;
+	gchar      **c_array;
+	gchar       *o_vendor, *o_product, *o_serial;
+	const gchar *values[4];
+
+	display  = gsd_gconf_get (device->priv->settings_path, device->priv->schemas_path, "display");
+	c_array  = gsd_gconf_value_get_strv (display, &nvalues);
+	g_strfreev (c_array);
+
+	if (nvalues != 3) {
+		gconf_value_free (display);
+		g_warning("Unable set set display property. Got %"G_GSIZE_FORMAT" items; expected %d items.\n", nvalues, 4);
+		return;
+	}
+
+	if (rr_output_info == NULL)
+	{
+		o_vendor  = g_strdup ("");
+		o_product = g_strdup ("");
+		o_serial  = g_strdup ("");
+	}
+	else
+	{
+		o_vendor = g_malloc0 (4);
+		gsd_rr_output_info_get_vendor (rr_output_info, o_vendor);
+		o_product = g_strdup_printf ("%d", gsd_rr_output_info_get_product (rr_output_info));
+		o_serial  = g_strdup_printf ("%d", gsd_rr_output_info_get_serial  (rr_output_info));
+	}
+
+	values[0] = o_vendor;
+	values[1] = o_product;
+	values[2] = o_serial;
+	values[3] = NULL;
+
+	nvalues = gsd_gconf_value_set_strv (display, values);
+	gsd_gconf_set (device->priv->settings_path, "display", display);
+	gconf_value_free (display);
+
+	g_free (o_vendor);
+	g_free (o_product);
+	g_free (o_serial);
+}
+
+void
+gsd_wacom_device_set_display (GsdWacomDevice *device,
+			      int	     monitor)
+{
+	GnomeOutputInfo *output = NULL;
+
+	g_return_if_fail (GSD_IS_WACOM_DEVICE (device));
+
+	if (monitor >= 0)
+		output = find_output_by_monitor (gdk_screen_get_default (), monitor);
+	set_display_by_output (device, output);
+	gsd_rr_compat_output_free (output);
+}
+
+static GnomeOutputInfo*
+find_output (GsdWacomDevice *device)
+{
+	GnomeOutputInfo *rr_output_info;
+
+	rr_output_info = find_output_by_display(device);
+
+	if (rr_output_info == NULL) {
+		if (gsd_wacom_device_is_screen_tablet (device)) {
+			rr_output_info = find_output_by_heuristic (device);
+			if (rr_output_info == NULL) {
+				g_warning ("No fuzzy match based on heuristics was found.");
+			} else {
+				g_warning("Automatically mapping tablet to heuristically-found display.");
+				set_display_by_output (device, rr_output_info);
+			}
+		}
+	}
+
+	return rr_output_info;
+}
+
+static void
+calculate_transformation_matrix (const GdkRectangle mapped, const GdkRectangle desktop, float matrix[NUM_ELEMS_MATRIX])
+{
+	float x_scale = (float)mapped.x / desktop.width;
+	float y_scale = (float)mapped.y / desktop.height;
+	float width_scale  = (float)mapped.width / desktop.width;
+	float height_scale = (float)mapped.height / desktop.height;
+
+	matrix[0] = width_scale;
+	matrix[1] = 0.0f;
+	matrix[2] = x_scale;
+
+	matrix[3] = 0.0f;
+	matrix[4] = height_scale;
+	matrix[5] = y_scale;
+
+	matrix[6] = 0.0f;
+	matrix[7] = 0.0f;
+	matrix[8] = 1.0f;
+
+	g_debug ("Matrix is %f,%f,%f,%f,%f,%f,%f,%f,%f.",
+		 matrix[0], matrix[1], matrix[2],
+		 matrix[3], matrix[4], matrix[5],
+		 matrix[6], matrix[7], matrix[8]);
+
+	return;
+}
+
+int
+gsd_wacom_device_get_display_monitor (GsdWacomDevice *device)
+{
+	gboolean is_active;
+	GnomeOutputInfo *rr_output_info;
+	gint monitor;
+
+	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), -1);
+
+	rr_output_info = find_output(device);
+	if (rr_output_info == NULL)
+		return -1;
+
+	is_active = gsd_rr_output_info_is_active (rr_output_info);
+	if (!is_active)
+	{
+		gsd_rr_compat_output_free (rr_output_info);
+		g_warning ("Output is not active.");
+		return -1;
+	}
+
+	if (rr_output_info->width <= 0 || rr_output_info->height <= 0)
+	{
+		gsd_rr_compat_output_free (rr_output_info);
+		g_warning ("Output has non-positive area.");
+		return -1;
+	}
+
+	g_debug ("Area: %d,%d %dx%d", rr_output_info->x, rr_output_info->y, rr_output_info->width, rr_output_info->height);
+	monitor = gdk_screen_get_monitor_at_point (gdk_screen_get_default (), rr_output_info->x, rr_output_info->y);
+	gsd_rr_compat_output_free (rr_output_info);
+
+	return monitor;
+}
+
+gboolean
+gsd_wacom_device_get_display_matrix (GsdWacomDevice *device, float matrix[NUM_ELEMS_MATRIX])
+{
+	int monitor;
+	GdkRectangle display;
+	GdkRectangle desktop;
+	GdkScreen *screen = gdk_screen_get_default ();
+
+	matrix[0] = 1.0f;
+	matrix[1] = 0.0f;
+	matrix[2] = 0.0f;
+	matrix[3] = 0.0f;
+	matrix[4] = 1.0f;
+	matrix[5] = 0.0f;
+	matrix[6] = 0.0f;
+	matrix[7] = 0.0f;
+	matrix[8] = 1.0f;
+
+	monitor = gsd_wacom_device_get_display_monitor (device);
+	if (monitor < 0)
+		return FALSE;
+
+	desktop.x = 0;
+	desktop.y = 0;
+	desktop.width = gdk_screen_get_width (screen);
+	desktop.height = gdk_screen_get_height (screen);
+
+	gdk_screen_get_monitor_geometry (screen, monitor, &display);
+	calculate_transformation_matrix (display, desktop, matrix);
+	return TRUE;
+}
+
+static void
+add_stylus_to_device (GsdWacomDevice *device,
+		      const char     *settings_path,
+		      int	     id)
+{
+	const WacomStylus *wstylus;
+
+	wstylus = libwacom_stylus_get_for_id (db, id);
+	if (wstylus) {
+		GsdWacomStylus *stylus;
+		char *stylus_settings_path;
+
+		if (device->priv->type == WACOM_TYPE_STYLUS &&
+		    libwacom_stylus_is_eraser (wstylus))
+			return;
+		if (device->priv->type == WACOM_TYPE_ERASER &&
+		    libwacom_stylus_is_eraser (wstylus) == FALSE)
+			return;
+
+		stylus_settings_path = g_strdup_printf ("%s/0x%x", settings_path, id);
+
+		if (device->priv->type == WACOM_TYPE_STYLUS) {
+			stylus = gsd_wacom_stylus_new (device, wstylus, stylus_settings_path, WACOM_STYLUS_SCHEMA);
+		} else {
+			stylus = gsd_wacom_stylus_new (device, wstylus, stylus_settings_path, WACOM_ERASER_SCHEMA);
+		}
+		g_free (stylus_settings_path);
+		device->priv->styli = g_list_prepend (device->priv->styli, stylus);
+	}
+}
+
+int
+gsd_wacom_device_set_next_mode (GsdWacomDevice *device,
+				int             group_id)
+{
+	int current_idx;
+	int num_modes;
+
+	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), -1);
+	current_idx = GPOINTER_TO_INT (g_hash_table_lookup (device->priv->modes, GINT_TO_POINTER(group_id)));
+	/* That means that the mode doesn't exist, see gsd_wacom_device_add_modes() */
+	g_return_val_if_fail (current_idx != 0, -1);
+
+	current_idx++;
+
+	num_modes = GPOINTER_TO_INT (g_hash_table_lookup (device->priv->num_modes, GINT_TO_POINTER(group_id)));
+
+	if (current_idx > num_modes)
+		current_idx = 1;
+
+	g_hash_table_insert (device->priv->modes, GINT_TO_POINTER (group_id), GINT_TO_POINTER (current_idx));
+
+	return current_idx;
+}
+
+static int
+flags_to_group (WacomButtonFlags flags)
+{
+	if (flags & WACOM_BUTTON_RING_MODESWITCH)
+		return 1;
+	if (flags & WACOM_BUTTON_RING2_MODESWITCH)
+		return 2;
+	if (flags & WACOM_BUTTON_TOUCHSTRIP_MODESWITCH)
+		return 3;
+	if (flags & WACOM_BUTTON_TOUCHSTRIP2_MODESWITCH)
+		return 4;
+
+	return 0;
+}
+
+static GList *
+gsd_wacom_device_add_ring_modes (WacomDevice	  *wacom_device,
+				 const char	  *settings_path,
+				 WacomButtonFlags  direction)
+{
+	GList *l;
+	guint num_modes;
+	guint i;
+	char *name, *id;
+
+	l = NULL;
+
+	if ((direction & WACOM_BUTTON_POSITION_LEFT) && libwacom_has_ring (wacom_device)) {
+		num_modes = libwacom_get_ring_num_modes (wacom_device);
+		for (i = 1; i <= num_modes; i++) {
+			name = g_strdup_printf (_("Left Ring Mode #%d"), i);
+			id = g_strdup_printf ("left-ring-mode-%d", i);
+			l = g_list_append (l, gsd_wacom_tablet_button_new (name, id, settings_path, WACOM_TABLET_BUTTON_TYPE_ELEVATOR, flags_to_group (WACOM_BUTTON_RING_MODESWITCH), i - 1));
+		}
+	} else if ((direction & WACOM_BUTTON_POSITION_RIGHT) && libwacom_has_ring2 (wacom_device)) {
+		num_modes = libwacom_get_ring2_num_modes (wacom_device);
+		for (i = 1; i <= num_modes; i++) {
+			name = g_strdup_printf (_("Right Ring Mode #%d"), i);
+			id = g_strdup_printf ("right-ring-mode-%d", i);
+			l = g_list_append (l, gsd_wacom_tablet_button_new (name, id, settings_path, WACOM_TABLET_BUTTON_TYPE_ELEVATOR, flags_to_group (WACOM_BUTTON_RING2_MODESWITCH), i - 1));
+		}
+	}
+
+	return l;
+}
+
+static GList *
+gsd_wacom_device_add_strip_modes (WacomDevice	   *wacom_device,
+				  const char	   *settings_path,
+				  WacomButtonFlags  direction)
+{
+	GList *l;
+	guint num_modes;
+	guint num_strips;
+	guint i;
+	char *name, *id;
+
+	l = NULL;
+	num_strips = libwacom_get_num_strips (wacom_device);
+	if (num_strips > 2)
+		g_warning ("Unhandled number of touchstrips: %d", num_strips);
+
+	if ((direction & WACOM_BUTTON_POSITION_LEFT) && num_strips >= 1) {
+		num_modes = libwacom_get_strips_num_modes (wacom_device);
+		for (i = 1; i <= num_modes; i++) {
+			name = g_strdup_printf (_("Left Touchstrip Mode #%d"), i);
+			id = g_strdup_printf ("left-strip-mode-%d", i);
+			l = g_list_append (l, gsd_wacom_tablet_button_new (name, id, settings_path, WACOM_TABLET_BUTTON_TYPE_ELEVATOR, flags_to_group (WACOM_BUTTON_TOUCHSTRIP_MODESWITCH), i - 1));
+		}
+	} else if ((direction & WACOM_BUTTON_POSITION_RIGHT) && num_strips >= 2) {
+		num_modes = libwacom_get_strips_num_modes (wacom_device);
+		for (i = 1; i <= num_modes; i++) {
+			name = g_strdup_printf (_("Right Touchstrip Mode #%d"), i);
+			id = g_strdup_printf ("right-strip-mode-%d", i);
+			l = g_list_append (l, gsd_wacom_tablet_button_new (name, id, settings_path, WACOM_TABLET_BUTTON_TYPE_ELEVATOR, flags_to_group (WACOM_BUTTON_TOUCHSTRIP2_MODESWITCH), i - 1));
+		}
+	}
+
+	return l;
+}
+
+static char *
+gsd_wacom_device_modeswitch_name (WacomButtonFlags flags,
+				  guint button_num)
+{
+	if (flags & WACOM_BUTTON_RINGS_MODESWITCH) {
+		if (flags & WACOM_BUTTON_POSITION_LEFT)
+			return g_strdup_printf (_("Left Touchring Mode Switch"));
+		else
+			return g_strdup_printf (_("Right Touchring Mode Switch"));
+	} else if (flags & WACOM_BUTTON_TOUCHSTRIPS_MODESWITCH) {
+		if (flags & WACOM_BUTTON_POSITION_LEFT)
+			return g_strdup_printf (_("Left Touchstrip Mode Switch"));
+		else
+			return g_strdup_printf (_("Right Touchstrip Mode Switch"));
+	}
+
+	g_warning ("Unhandled modeswitch and direction combination");
+
+	return g_strdup_printf (_("Mode Switch #%d"), button_num);
+}
+
+static GList *
+gsd_wacom_device_add_buttons_dir (WacomDevice	   *wacom_device,
+				  const char	   *settings_path,
+				  WacomButtonFlags  direction,
+				  const char	   *button_str,
+				  const char	   *button_str_id)
+{
+	GList *l;
+	guint num_buttons, i, button_num;
+	char *name, *id;
+
+	l = NULL;
+	button_num = 1;
+	num_buttons = libwacom_get_num_buttons (wacom_device);
+	for (i = 'A'; i < 'A' + num_buttons; i++) {
+		WacomButtonFlags flags;
+
+		flags = libwacom_get_button_flag (wacom_device, i);
+		if (!(flags & direction))
+			continue;
+		/* Ignore mode switches */
+		if (flags & WACOM_BUTTON_MODESWITCH)
+			continue;
+
+		name = g_strdup_printf (button_str, button_num++);
+		id = g_strdup_printf ("%s%c", button_str_id, i);
+		l = g_list_append (l, gsd_wacom_tablet_button_new (name, id, settings_path, WACOM_TABLET_BUTTON_TYPE_NORMAL, flags_to_group (flags), -1));
+		g_free (name);
+		g_free (id);
+	}
+
+	/* Handle modeswitches */
+	for (i = 'A'; i < 'A' + num_buttons; i++) {
+		WacomButtonFlags flags;
+		char *name, *id;
+
+		flags = libwacom_get_button_flag (wacom_device, i);
+		if (!(flags & direction))
+			continue;
+		/* Ignore non-mode switches */
+		if (!(flags & WACOM_BUTTON_MODESWITCH))
+			continue;
+
+		name = gsd_wacom_device_modeswitch_name (flags, button_num++);
+		id = g_strdup_printf ("%s%c", button_str_id, i);
+		l = g_list_append (l, gsd_wacom_tablet_button_new (name, id, settings_path, WACOM_TABLET_BUTTON_TYPE_HARDCODED, flags_to_group (flags), -1));
+		g_free (name);
+		g_free (id);
+
+		if (flags & WACOM_BUTTON_RINGS_MODESWITCH)
+			l = g_list_concat (l, gsd_wacom_device_add_ring_modes (wacom_device, settings_path, direction));
+		else if (flags & WACOM_BUTTON_TOUCHSTRIPS_MODESWITCH)
+			l = g_list_concat (l, gsd_wacom_device_add_strip_modes (wacom_device, settings_path, direction));
+		else
+			g_warning ("Unhandled modeswitches");
+	}
+
+	return l;
+}
+
+static void
+gsd_wacom_device_add_buttons (GsdWacomDevice	*device,
+			      WacomDevice	*wacom_device,
+			      const char	*settings_path)
+{
+	GList *l, *ret;
+
+	ret = NULL;
+
+	l = gsd_wacom_device_add_buttons_dir (wacom_device, settings_path, WACOM_BUTTON_POSITION_LEFT, _("Left Button #%d"), "button");
+	if (l)
+		ret = l;
+	l = gsd_wacom_device_add_buttons_dir (wacom_device, settings_path, WACOM_BUTTON_POSITION_RIGHT, _("Right Button #%d"), "button");
+	if (l)
+		ret = g_list_concat (ret, l);
+	l = gsd_wacom_device_add_buttons_dir (wacom_device, settings_path, WACOM_BUTTON_POSITION_TOP, _("Top Button #%d"), "button");
+	if (l)
+		ret = g_list_concat (ret, l);
+	l = gsd_wacom_device_add_buttons_dir (wacom_device, settings_path, WACOM_BUTTON_POSITION_BOTTOM, _("Bottom Button #%d"), "button");
+	if (l)
+		ret = g_list_concat (ret, l);
+
+	device->priv->buttons = ret;
+}
+
+static void
+gsd_wacom_device_add_modes (GsdWacomDevice *device,
+			    WacomDevice    *wacom_device)
+{
+	GList *l;
+
+	device->priv->modes = g_hash_table_new (g_direct_hash, g_direct_equal);
+	device->priv->num_modes = g_hash_table_new (g_direct_hash, g_direct_equal);
+
+	for (l = device->priv->buttons; l != NULL; l = l->next) {
+		GsdWacomTabletButton *button = l->data;
+
+		if (button->group_id > 0)
+			g_hash_table_insert (device->priv->modes, GINT_TO_POINTER (button->group_id), GINT_TO_POINTER (1));
+
+		/* See flags_to_group() for group ID/button type matches */
+		if (button->group_id == 1) {
+			g_hash_table_insert (device->priv->num_modes,
+					     GINT_TO_POINTER (button->group_id),
+					     GINT_TO_POINTER (libwacom_get_ring_num_modes (wacom_device)));
+		} else if (button->group_id == 2) {
+			g_hash_table_insert (device->priv->num_modes,
+					     GINT_TO_POINTER (button->group_id),
+					     GINT_TO_POINTER (libwacom_get_ring2_num_modes (wacom_device)));
+		} else if (button->group_id == 3 || button->group_id == 4) {
+			g_hash_table_insert (device->priv->num_modes,
+					     GINT_TO_POINTER (button->group_id),
+					     GINT_TO_POINTER (libwacom_get_strips_num_modes (wacom_device)));
+		}
+	}
+}
+
+static void
+gsd_wacom_device_update_from_db (GsdWacomDevice *device,
+				 WacomDevice    *wacom_device,
+				 const char     *identifier)
+{
+	char *schemas_path;
+	char *settings_path;
+
+	schemas_path =  g_strdup (WACOM_TABLET_SCHEMA);
+	settings_path = gsd_gconf_build_path (WACOM_DEVICE_CONFIG_BASE, libwacom_get_match (wacom_device));
+
+	device->priv->name = g_strdup (libwacom_get_name (wacom_device));
+	device->priv->schemas_path = schemas_path;
+	device->priv->settings_path = settings_path;
+
+	device->priv->reversible = libwacom_is_reversible (wacom_device);
+	device->priv->is_screen_tablet = libwacom_is_builtin (wacom_device);
+	if (device->priv->is_screen_tablet) {
+		if (libwacom_get_class (wacom_device) == WCLASS_CINTIQ)
+			device->priv->icon_name = g_strdup ("wacom-tablet-cintiq");
+		else
+			device->priv->icon_name = g_strdup ("wacom-tablet-pc");
+	} else {
+		device->priv->icon_name = g_strdup ("wacom-tablet");
+	}
+
+	if (device->priv->type == WACOM_TYPE_PAD) {
+		gsd_wacom_device_add_buttons (device, wacom_device, settings_path);
+		gsd_wacom_device_add_modes (device, wacom_device);
+	}
+
+	if (device->priv->type == WACOM_TYPE_STYLUS ||
+	    device->priv->type == WACOM_TYPE_ERASER) {
+		int *ids;
+		int num_styli;
+		guint i;
+
+		ids = libwacom_get_supported_styli(wacom_device, &num_styli);
+		for (i = 0; i < num_styli; i++)
+			add_stylus_to_device (device, settings_path, ids[i]);
+		/* Create a fallback stylus if we don't have one */
+		if (num_styli == 0)
+			add_stylus_to_device (device, settings_path,
+					      device->priv->type == WACOM_TYPE_STYLUS ?
+					      WACOM_STYLUS_FALLBACK_ID : WACOM_ERASER_FALLBACK_ID);
+
+		device->priv->styli = g_list_reverse (device->priv->styli);
+	}
+}
+
+static GObject *
+gsd_wacom_device_constructor (GType		     type,
+			      guint		      n_construct_properties,
+			      GObjectConstructParam     *construct_properties)
+{
+	GsdWacomDevice *device;
+	GsdDeviceManager *device_manager;
+	XDeviceInfo *device_info;
+	WacomDevice *wacom_device;
+	int n_devices;
+	guint i;
+	char *path;
+
+	device = GSD_WACOM_DEVICE (G_OBJECT_CLASS (gsd_wacom_device_parent_class)->constructor (type,
+												n_construct_properties,
+												construct_properties));
+
+	if (device->priv->device_info == NULL)
+		return G_OBJECT (device);
+
+	device_manager = gsd_display_get_device_manager (gdk_display_get_default ());
+	device->priv->opcode = gsd_device_manager_get_opcode (device_manager);
+
+	device->priv->device_id = device->priv->device_info->id;
+
+	if (!supports_xinput_devices(&device->priv->opcode))
+		return G_OBJECT (device);
+
+	device_info = XListInputDevices (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), &n_devices);
+	if (device_info == NULL) {
+		g_warning ("Could not list any input devices through XListInputDevices()");
+		goto end;
+	}
+
+	for (i = 0; i < n_devices; i++) {
+		if (device_info[i].id == device->priv->device_id) {
+			device->priv->type = get_device_type (&device_info[i]);
+			device->priv->tool_name = g_strdup (device_info[i].name);
+			break;
+		}
+	}
+
+	XFreeDeviceList (device_info);
+
+	if (device->priv->type == WACOM_TYPE_INVALID)
+		goto end;
+
+	path = xdevice_get_device_node (device->priv->device_id);
+	if (path == NULL) {
+		g_warning ("Could not get the device node path for ID '%d'", device->priv->device_id);
+		device->priv->type = WACOM_TYPE_INVALID;
+		goto end;
+	}
+
+	if (db == NULL)
+		db = libwacom_database_new ();
+
+	wacom_device = libwacom_new_from_path (db, path, FALSE, NULL);
+	if (!wacom_device) {
+		WacomError *wacom_error;
+
+		g_debug ("Creating fallback driver for wacom tablet '%s' ('%s')",
+			 device->priv->device_info->name,
+			 path);
+
+		wacom_error = libwacom_error_new ();
+		wacom_device = libwacom_new_from_path (db, path, TRUE, wacom_error);
+		if (wacom_device == NULL) {
+			g_warning ("Failed to create fallback wacom device for '%s': %s (%d)",
+				   path,
+				   libwacom_error_get_message (wacom_error),
+				   libwacom_error_get_code (wacom_error));
+			g_free (path);
+			libwacom_error_free (&wacom_error);
+			device->priv->type = WACOM_TYPE_INVALID;
+			goto end;
+		}
+	}
+
+	gsd_wacom_device_update_from_db (device, wacom_device, path);
+	libwacom_destroy (wacom_device);
+	g_free (path);
+
+	if (device->priv->type == WACOM_TYPE_STYLUS ||
+	    device->priv->type == WACOM_TYPE_ERASER) {
+		setup_property_notify (device);
+	}
+
+end:
+	return G_OBJECT (device);
+}
+
+static void
+gsd_wacom_device_set_property (GObject	*object,
+			       guint	   prop_id,
+			       const GValue   *value,
+			       GParamSpec     *pspec)
+{
+	GsdWacomDevice *device;
+
+	device = GSD_WACOM_DEVICE (object);
+
+	switch (prop_id) {
+	case PROP_DEVICE_INFO:
+		device->priv->device_info = g_value_get_pointer (value);
+		break;
+	case PROP_LAST_STYLUS:
+		device->priv->last_stylus = g_value_get_pointer (value);
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
+gsd_wacom_device_get_property (GObject	*object,
+			       guint	   prop_id,
+			       GValue	 *value,
+			       GParamSpec     *pspec)
+{
+	GsdWacomDevice *device;
+
+	device = GSD_WACOM_DEVICE (object);
+
+	switch (prop_id) {
+	case PROP_DEVICE_INFO:
+		g_value_set_pointer (value, device->priv->device_info);
+		break;
+	case PROP_LAST_STYLUS:
+		g_value_set_pointer (value, device->priv->last_stylus);
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
+gsd_wacom_device_class_init (GsdWacomDeviceClass *klass)
+{
+	GObjectClass   *object_class = G_OBJECT_CLASS (klass);
+
+	object_class->constructor	= gsd_wacom_device_constructor;
+	object_class->finalize		= gsd_wacom_device_finalize;
+	object_class->set_property	= gsd_wacom_device_set_property;
+	object_class->get_property	= gsd_wacom_device_get_property;
+
+	g_type_class_add_private (klass, sizeof (GsdWacomDevicePrivate));
+
+	g_object_class_install_property (object_class, PROP_DEVICE_INFO,
+					 g_param_spec_pointer ("device-info", "device-info", "device-info",
+							       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+	g_object_class_install_property (object_class, PROP_LAST_STYLUS,
+					 g_param_spec_pointer ("last-stylus", "last-stylus", "last-stylus",
+							       G_PARAM_READWRITE));
+}
+
+static void
+gsd_wacom_device_init (GsdWacomDevice *device)
+{
+	device->priv = GSD_WACOM_DEVICE_GET_PRIVATE (device);
+	device->priv->type = WACOM_TYPE_INVALID;
+}
+
+static void
+gsd_wacom_device_finalize (GObject *object)
+{
+	GsdWacomDevice *device;
+	GsdWacomDevicePrivate *p;
+
+	g_return_if_fail (object != NULL);
+	g_return_if_fail (GSD_IS_WACOM_DEVICE (object));
+
+	device = GSD_WACOM_DEVICE (object);
+
+	g_return_if_fail (device->priv != NULL);
+
+	p = device->priv;
+
+	g_list_foreach (p->buttons, (GFunc) gsd_wacom_tablet_button_free, NULL);
+	g_list_free (p->buttons);
+
+	g_free (p->settings_path);
+	p->settings_path = NULL;
+
+	g_free (p->name);
+	p->name = NULL;
+
+	g_free (p->tool_name);
+	p->tool_name = NULL;
+
+	g_free (p->icon_name);
+	p->icon_name = NULL;
+
+	if (p->modes) {
+		g_hash_table_destroy (p->modes);
+		p->modes = NULL;
+	}
+	if (p->num_modes) {
+		g_hash_table_destroy (p->num_modes);
+		p->num_modes = NULL;
+	}
+
+	gdk_window_remove_filter (NULL,
+				  (GdkFilterFunc) filter_events,
+				  device);
+
+	G_OBJECT_CLASS (gsd_wacom_device_parent_class)->finalize (object);
+}
+
+GsdWacomDevice *
+gsd_wacom_device_new (XDeviceInfo *device_info)
+{
+	return GSD_WACOM_DEVICE (g_object_new (GSD_TYPE_WACOM_DEVICE,
+				 "device_info", device_info,
+				 NULL));
+}
+
+GList *
+gsd_wacom_device_list_styli (GsdWacomDevice *device)
+{
+	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), NULL);
+
+	return g_list_copy (device->priv->styli);
+}
+
+GsdWacomStylus *
+gsd_wacom_device_get_stylus_for_type (GsdWacomDevice     *device,
+				      GsdWacomStylusType  type)
+{
+	GList *l;
+
+	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), NULL);
+
+	for (l = device->priv->styli; l != NULL; l = l->next) {
+		GsdWacomStylus *stylus = l->data;
+
+		if (gsd_wacom_stylus_get_stylus_type (stylus) == type)
+			return stylus;
+	}
+	return NULL;
+}
+
+GsdWacomStylus *
+gsd_wacom_device_get_stylus_for_path (GsdWacomDevice *device,
+				      const char     *settings_path)
+{
+	GList *l;
+
+	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), NULL);
+	g_return_val_if_fail (settings_path != NULL, NULL);
+
+	for (l = device->priv->styli; l != NULL; l = l->next) {
+		GsdWacomStylus *stylus = l->data;
+
+		if (strcmp (stylus->priv->settings_path, settings_path) == 0)
+			return stylus;
+      }
+   return NULL;
+}
+
+const char *
+gsd_wacom_device_get_name (GsdWacomDevice *device)
+{
+	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), NULL);
+
+	return device->priv->name;
+}
+
+const char *
+gsd_wacom_device_get_icon_name (GsdWacomDevice *device)
+{
+	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), NULL);
+
+	return device->priv->icon_name;
+}
+
+const char *
+gsd_wacom_device_get_tool_name (GsdWacomDevice *device)
+{
+	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), NULL);
+
+	return device->priv->tool_name;
+}
+
+gboolean
+gsd_wacom_device_reversible (GsdWacomDevice *device)
+{
+	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), FALSE);
+
+	return device->priv->reversible;
+}
+
+gboolean
+gsd_wacom_device_is_screen_tablet (GsdWacomDevice *device)
+{
+	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), FALSE);
+
+	return device->priv->is_screen_tablet;
+}
+
+const char *
+gsd_wacom_device_get_settings_path (GsdWacomDevice *device)
+{
+	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), NULL);
+
+	return device->priv->settings_path;
+}
+
+const char *
+gsd_wacom_device_get_schemas_path (GsdWacomDevice *device)
+{
+	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), NULL);
+
+	return device->priv->schemas_path;
+}
+
+void
+gsd_wacom_device_set_current_stylus (GsdWacomDevice *device,
+				     int	     stylus_id)
+{
+	GList *l;
+	GsdWacomStylus *stylus;
+
+	g_return_if_fail (GSD_IS_WACOM_DEVICE (device));
+
+	/* Don't change anything if the stylus is already set */
+	if (device->priv->last_stylus != NULL) {
+		GsdWacomStylus *stylus = device->priv->last_stylus;
+		if (stylus->priv->id == stylus_id)
+			return;
+	}
+
+	for (l = device->priv->styli; l; l = l->next) {
+		stylus = l->data;
+
+		/* Set a nice default if 0x0 */
+		if (stylus_id == 0x0 &&
+		    stylus->priv->type == WSTYLUS_GENERAL) {
+			g_object_set (device, "last-stylus", stylus, NULL);
+			return;
+		}
+
+		if (stylus->priv->id == stylus_id) {
+			g_object_set (device, "last-stylus", stylus, NULL);
+			return;
+		}
+	}
+
+	/* Setting the default stylus to be the generic one */
+	for (l = device->priv->styli; l; l = l->next) {
+		stylus = l->data;
+
+		/* Set a nice default if 0x0 */
+		if (stylus->priv->type == WSTYLUS_GENERAL) {
+			g_debug ("Could not find stylus ID 0x%x for tablet '%s', setting general pen ID 0x%x instead",
+				 stylus_id, device->priv->name, stylus->priv->id);
+			g_object_set (device, "last-stylus", stylus, NULL);
+			return;
+		}
+	}
+
+	g_warning ("Could not set the current stylus ID 0x%x for tablet '%s', no general pen found",
+		   stylus_id, device->priv->name);
+
+	/* Setting the default stylus to be the first one */
+	g_assert (device->priv->styli);
+
+	stylus = device->priv->styli->data;
+	g_object_set (device, "last-stylus", stylus, NULL);
+}
+
+GsdWacomDeviceType
+gsd_wacom_device_get_device_type (GsdWacomDevice *device)
+{
+	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), WACOM_TYPE_INVALID);
+
+	return device->priv->type;
+}
+
+gint *
+gsd_wacom_device_get_area (GsdWacomDevice *device)
+{
+	int i, id;
+	XDevice *xdevice;
+	Atom area, realtype;
+	int rc, realformat;
+	unsigned long nitems, bytes_after;
+	unsigned char *data = NULL;
+	gint *device_area;
+
+	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), NULL);
+
+	id = device->priv->device_info->id;
+
+	area = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), "Wacom Tablet Area", False);
+
+	gdk_error_trap_push ();
+	xdevice = XOpenDevice (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), id);
+	if (gdk_error_trap_pop () || (device == NULL))
+		return NULL;
+
+	gdk_error_trap_push ();
+	rc = XGetDeviceProperty (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
+				 xdevice, area, 0, 4, False,
+				 XA_INTEGER, &realtype, &realformat, &nitems,
+				 &bytes_after, &data);
+	if (gdk_error_trap_pop () || rc != Success || realtype == None || bytes_after != 0 || nitems != 4) {
+		XCloseDevice (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), xdevice);
+		return NULL;
+	}
+
+	device_area = g_new0 (int, nitems);
+	for (i = 0; i < nitems; i++)
+		device_area[i] = ((long*)data)[i];
+
+	XFree (data);
+	XCloseDevice (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), xdevice);
+
+	return device_area;
+}
+
+const char *
+gsd_wacom_device_type_to_string (GsdWacomDeviceType type)
+{
+	switch (type) {
+	case WACOM_TYPE_INVALID:
+		return "Invalid";
+	case WACOM_TYPE_STYLUS:
+		return "Stylus";
+	case WACOM_TYPE_ERASER:
+		return "Eraser";
+	case WACOM_TYPE_CURSOR:
+		return "Cursor";
+	case WACOM_TYPE_PAD:
+		return "Pad";
+	case WACOM_TYPE_TOUCH:
+		return "Touch";
+	default:
+		return "Unknown type";
+	}
+}
+
+GList *
+gsd_wacom_device_get_buttons (GsdWacomDevice *device)
+{
+	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), NULL);
+
+	return g_list_copy (device->priv->buttons);
+}
+
+static GsdWacomTabletButton *
+find_button_with_id (GsdWacomDevice *device,
+		     const char     *id)
+{
+	GList *l;
+
+	for (l = device->priv->buttons; l != NULL; l = l->next) {
+		GsdWacomTabletButton *button = l->data;
+
+		if (g_strcmp0 (button->id, id) == 0)
+			return button;
+	}
+	return NULL;
+}
+
+static GsdWacomTabletButton *
+find_button_with_index (GsdWacomDevice *device,
+			const char     *id,
+			int             index)
+{
+	GsdWacomTabletButton *button;
+	char *str;
+
+	str = g_strdup_printf ("%s-mode-%d", id, index);
+	button = find_button_with_id (device, str);
+	g_free (str);
+
+	return button;
+}
+
+GsdWacomTabletButton *
+gsd_wacom_device_get_button (GsdWacomDevice   *device,
+			     int	       button,
+			     GtkDirectionType *dir)
+{
+	int index;
+
+	if (button <= 26) {
+		char *id;
+		GsdWacomTabletButton *ret;
+		int physical_button;
+
+		/* mouse_button = physical_button < 4 ? physical_button : physical_button + 4 */
+		if (button > 4)
+			physical_button = button - 4;
+		else
+			physical_button = button;
+
+		id = g_strdup_printf ("button%c", 'A' + physical_button - 1);
+		ret = find_button_with_id (device, id);
+		g_free (id);
+
+		return ret;
+	}
+
+	switch (button) {
+	case 90:
+	case 92:
+	case 94:
+	case 96:
+		*dir = GTK_DIR_UP;
+		break;
+	case 91:
+	case 93:
+	case 95:
+	case 97:
+		*dir = GTK_DIR_DOWN;
+		break;
+	default:
+		;;
+	}
+
+	/* The group ID is implied by the button number */
+	switch (button) {
+	case 90:
+	case 91:
+		index = GPOINTER_TO_INT (g_hash_table_lookup (device->priv->modes, GINT_TO_POINTER (1)));
+		return find_button_with_index (device, "left-ring", index);
+	case 92:
+	case 93:
+		index = GPOINTER_TO_INT (g_hash_table_lookup (device->priv->modes, GINT_TO_POINTER (2)));
+		return find_button_with_index (device, "right-ring", index);
+	case 94:
+	case 95:
+		index = GPOINTER_TO_INT (g_hash_table_lookup (device->priv->modes, GINT_TO_POINTER (3)));
+		return find_button_with_index (device, "left-strip", index);
+	case 96:
+	case 97:
+		index = GPOINTER_TO_INT (g_hash_table_lookup (device->priv->modes, GINT_TO_POINTER (4)));
+		return find_button_with_index (device, "right-strip", index);
+	default:
+		return NULL;
+	}
+}
+
+GsdWacomDevice *
+gsd_wacom_device_create_fake (GsdWacomDeviceType  type,
+			      const char	 *name,
+			      const char	 *tool_name)
+{
+	GsdWacomDevice *device;
+	GsdWacomDevicePrivate *priv;
+	WacomDevice *wacom_device;
+
+	device = GSD_WACOM_DEVICE (g_object_new (GSD_TYPE_WACOM_DEVICE, NULL));
+
+	if (db == NULL)
+		db = libwacom_database_new ();
+
+	wacom_device = libwacom_new_from_name (db, name, NULL);
+	if (wacom_device == NULL)
+		return NULL;
+
+	priv = device->priv;
+	priv->type = type;
+	priv->tool_name = g_strdup (tool_name);
+	gsd_wacom_device_update_from_db (device, wacom_device, name);
+	libwacom_destroy (wacom_device);
+
+	return device;
+}
+
+GList *
+gsd_wacom_device_create_fake_cintiq (void)
+{
+	GsdWacomDevice *device;
+	GList *devices;
+
+	device = gsd_wacom_device_create_fake (WACOM_TYPE_STYLUS,
+					       "Wacom Cintiq 21UX2",
+					       "Wacom Cintiq 21UX2 stylus");
+	devices = g_list_prepend (NULL, device);
+
+	device = gsd_wacom_device_create_fake (WACOM_TYPE_ERASER,
+					       "Wacom Cintiq 21UX2",
+					       "Wacom Cintiq 21UX2 eraser");
+	devices = g_list_prepend (devices, device);
+
+	device = gsd_wacom_device_create_fake (WACOM_TYPE_PAD,
+					       "Wacom Cintiq 21UX2",
+					       "Wacom Cintiq 21UX2 pad");
+	devices = g_list_prepend (devices, device);
+
+	return devices;
+}
+
+GList *
+gsd_wacom_device_create_fake_bt (void)
+{
+	GsdWacomDevice *device;
+	GList *devices;
+
+	device = gsd_wacom_device_create_fake (WACOM_TYPE_STYLUS,
+					       "Wacom Graphire Wireless",
+					       "Graphire Wireless stylus");
+	devices = g_list_prepend (NULL, device);
+
+	device = gsd_wacom_device_create_fake (WACOM_TYPE_ERASER,
+					       "Wacom Graphire Wireless",
+					       "Graphire Wireless eraser");
+	devices = g_list_prepend (devices, device);
+
+	device = gsd_wacom_device_create_fake (WACOM_TYPE_PAD,
+					       "Wacom Graphire Wireless",
+					       "Graphire Wireless pad");
+	devices = g_list_prepend (devices, device);
+
+	device = gsd_wacom_device_create_fake (WACOM_TYPE_CURSOR,
+					       "Wacom Graphire Wireless",
+					       "Graphire Wireless cursor");
+	devices = g_list_prepend (devices, device);
+
+	return devices;
+}
+
+GList *
+gsd_wacom_device_create_fake_x201 (void)
+{
+	GsdWacomDevice *device;
+	GList *devices;
+
+	device = gsd_wacom_device_create_fake (WACOM_TYPE_STYLUS,
+					       "Wacom Serial Tablet WACf004",
+					       "Wacom Serial Tablet WACf004 stylus");
+	devices = g_list_prepend (NULL, device);
+
+	device = gsd_wacom_device_create_fake (WACOM_TYPE_ERASER,
+					       "Wacom Serial Tablet WACf004",
+					       "Wacom Serial Tablet WACf004 eraser");
+	devices = g_list_prepend (devices, device);
+
+	return devices;
+}
+
+GList *
+gsd_wacom_device_create_fake_intuos4 (void)
+{
+	GsdWacomDevice *device;
+	GList *devices;
+
+	device = gsd_wacom_device_create_fake (WACOM_TYPE_STYLUS,
+					       "Wacom Intuos4 6x9",
+					       "Wacom Intuos4 6x9 stylus");
+	devices = g_list_prepend (NULL, device);
+
+	device = gsd_wacom_device_create_fake (WACOM_TYPE_ERASER,
+					       "Wacom Intuos4 6x9",
+					       "Wacom Intuos4 6x9 eraser");
+	devices = g_list_prepend (devices, device);
+
+	device = gsd_wacom_device_create_fake (WACOM_TYPE_PAD,
+					       "Wacom Intuos4 6x9",
+					       "Wacom Intuos4 6x9 pad");
+	devices = g_list_prepend (devices, device);
+
+	device = gsd_wacom_device_create_fake (WACOM_TYPE_CURSOR,
+					       "Wacom Intuos4 6x9",
+					       "Wacom Intuos4 6x9 cursor");
+	devices = g_list_prepend (devices, device);
+
+	return devices;
+}
+
+/* Some additional helper functions that can be shared with g-c-c */
+
+GsdWacomActionType
+gsd_wacom_get_action_type_from_name (const char *action_type)
+{
+	g_return_val_if_fail (action_type != NULL, GSD_WACOM_ACTION_TYPE_NONE);
+
+	if (g_ascii_strcasecmp ("custom", action_type) == 0)
+		return GSD_WACOM_ACTION_TYPE_CUSTOM;
+	/* Default */
+	return GSD_WACOM_ACTION_TYPE_NONE;
+}
+
+GsdWacomRotation
+gsd_wacom_get_rotation_type_from_name (const char *rotation)
+{
+	g_return_val_if_fail (rotation != NULL, GSD_WACOM_ROTATION_NONE);
+
+	if (g_ascii_strcasecmp ("cw", rotation) == 0)
+		return GSD_WACOM_ROTATION_CW;
+	else if (g_ascii_strcasecmp ("ccw", rotation) == 0)
+		return GSD_WACOM_ROTATION_CCW;
+	else if (g_ascii_strcasecmp ("half", rotation) == 0)
+		return GSD_WACOM_ROTATION_HALF;
+	/* Default */
+	return GSD_WACOM_ROTATION_NONE;
+}
+
+const char *
+gsd_wacom_get_action_name_from_type (GsdWacomActionType type)
+{
+	switch (type) {
+	case GSD_WACOM_ACTION_TYPE_CUSTOM:
+		return "custom";
+		break;
+	default: /* GSD_WACOM_ROTATION_NONE */
+		return "none";
+		break;
+	}
+	/* Default - not reached */
+	return "none";
+}
+
+const char *
+gsd_wacom_get_rotation_name_from_type (GsdWacomRotation type)
+{
+	switch (type) {
+	case GSD_WACOM_ROTATION_CW:
+		return "cw";
+		break;
+	case GSD_WACOM_ROTATION_CCW:
+		return "ccw";
+		break;
+	case GSD_WACOM_ROTATION_HALF:
+		return "half";
+		break;
+	default: /* GSD_WACOM_ROTATION_NONE */
+		return "none";
+		break;
+	}
+
+	/* Default - not reached */
+	return "none";
+}
diff -up gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-device.h.wacom gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-device.h
--- gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-device.h.wacom	2012-03-05 16:52:15.279449922 -0500
+++ gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-device.h	2012-03-05 16:52:15.279449922 -0500
@@ -0,0 +1,200 @@
+/*
+ * Copyright (C) 2011 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Author: Bastien Nocera <hadess@hadess.net>
+ *
+ */
+
+#ifndef __GSD_WACOM_DEVICE_MANAGER_H
+#define __GSD_WACOM_DEVICE_MANAGER_H
+
+#include <glib-object.h>
+#include <X11/extensions/XInput.h>
+#include <X11/extensions/XIproto.h>
+#include "gsd-wacom-gconf-helpers.h"
+
+G_BEGIN_DECLS
+
+/* Move enums here to avoid duplicating gsd-enums.h */
+typedef enum
+{
+  GSD_WACOM_ROTATION_NONE,
+  GSD_WACOM_ROTATION_CW,
+  GSD_WACOM_ROTATION_CCW,
+  GSD_WACOM_ROTATION_HALF
+} GsdWacomRotation;
+
+typedef enum
+{
+  GSD_WACOM_ACTION_TYPE_NONE,
+  GSD_WACOM_ACTION_TYPE_CUSTOM
+} GsdWacomActionType;
+
+#define NUM_ELEMS_MATRIX 9
+
+#define GSD_TYPE_WACOM_DEVICE		(gsd_wacom_device_get_type ())
+#define GSD_WACOM_DEVICE(o)		(G_TYPE_CHECK_INSTANCE_CAST ((o), GSD_TYPE_WACOM_DEVICE, GsdWacomDevice))
+#define GSD_WACOM_DEVICE_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), GSD_TYPE_WACOM_DEVICE, GsdWacomDeviceClass))
+#define GSD_IS_WACOM_DEVICE(o)		(G_TYPE_CHECK_INSTANCE_TYPE ((o), GSD_TYPE_WACOM_DEVICE))
+#define GSD_IS_WACOM_DEVICE_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), GSD_TYPE_WACOM_DEVICE))
+#define GSD_WACOM_DEVICE_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), GSD_TYPE_WACOM_DEVICE, GsdWacomDeviceClass))
+
+typedef struct GsdWacomDevicePrivate GsdWacomDevicePrivate;
+
+typedef struct
+{
+	GObject			parent;
+	GsdWacomDevicePrivate  *priv;
+} GsdWacomDevice;
+
+typedef struct
+{
+	GObjectClass   		parent_class;
+} GsdWacomDeviceClass;
+
+#define GSD_TYPE_WACOM_STYLUS		(gsd_wacom_stylus_get_type ())
+#define GSD_WACOM_STYLUS(o)		(G_TYPE_CHECK_INSTANCE_CAST ((o), GSD_TYPE_WACOM_STYLUS, GsdWacomStylus))
+#define GSD_WACOM_STYLUS_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), GSD_TYPE_WACOM_STYLUS, GsdWacomStylusClass))
+#define GSD_IS_WACOM_STYLUS(o)		(G_TYPE_CHECK_INSTANCE_TYPE ((o), GSD_TYPE_WACOM_STYLUS))
+#define GSD_IS_WACOM_STYLUS_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), GSD_TYPE_WACOM_STYLUS))
+#define GSD_WACOM_STYLUS_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), GSD_TYPE_WACOM_STYLUS, GsdWacomStylusClass))
+
+typedef struct GsdWacomStylusPrivate GsdWacomStylusPrivate;
+
+typedef struct
+{
+	GObject			parent;
+	GsdWacomStylusPrivate  *priv;
+} GsdWacomStylus;
+
+typedef struct
+{
+	GObjectClass   		parent_class;
+} GsdWacomStylusClass;
+
+typedef enum {
+	WACOM_STYLUS_TYPE_UNKNOWN,
+	WACOM_STYLUS_TYPE_GENERAL,
+	WACOM_STYLUS_TYPE_INKING,
+	WACOM_STYLUS_TYPE_AIRBRUSH,
+	WACOM_STYLUS_TYPE_CLASSIC,
+	WACOM_STYLUS_TYPE_MARKER,
+	WACOM_STYLUS_TYPE_STROKE,
+	WACOM_STYLUS_TYPE_PUCK
+} GsdWacomStylusType;
+
+GType			gsd_wacom_stylus_get_type		(void);
+const char *		gsd_wacom_stylus_get_settings_path	(GsdWacomStylus *stylus);
+const char * 		gsd_wacom_stylus_get_schemas_path	(GsdWacomStylus *stylus);
+const char * 		gsd_wacom_stylus_get_name		(GsdWacomStylus *stylus);
+const char * 		gsd_wacom_stylus_get_icon_name		(GsdWacomStylus *stylus);
+GsdWacomDevice *	gsd_wacom_stylus_get_device		(GsdWacomStylus *stylus);
+gboolean		gsd_wacom_stylus_get_has_eraser		(GsdWacomStylus *stylus);
+guint			gsd_wacom_stylus_get_num_buttons	(GsdWacomStylus *stylus);
+int			gsd_wacom_stylus_get_id	 	(GsdWacomStylus *stylus);
+GsdWacomStylusType gsd_wacom_stylus_get_stylus_type		(GsdWacomStylus *stylus);
+
+/* Tablet Buttons */
+typedef enum {
+	WACOM_TABLET_BUTTON_TYPE_NORMAL,
+	WACOM_TABLET_BUTTON_TYPE_ELEVATOR,
+	WACOM_TABLET_BUTTON_TYPE_HARDCODED
+} GsdWacomTabletButtonType;
+
+#define MAX_GROUP_ID 4
+
+typedef struct
+{
+	char			 *name;
+	char			 *id;
+	char 			 *settings_path;
+	char 			 *schemas_path;
+	GsdWacomTabletButtonType  type;
+	int			  group_id, idx;
+} GsdWacomTabletButton;
+
+void			gsd_wacom_tablet_button_free (GsdWacomTabletButton *button);
+GsdWacomTabletButton *	gsd_wacom_tablet_button_copy (GsdWacomTabletButton *button);
+const char *		gsd_wacom_tablet_button_get_settings_path
+						     (GsdWacomTabletButton *button);
+const char *		gsd_wacom_tablet_button_get_schemas_path
+						     (GsdWacomTabletButton *button);
+
+/* Device types to apply a setting to */
+typedef enum {
+	WACOM_TYPE_INVALID =     0,
+	WACOM_TYPE_STYLUS  =     (1 << 1),
+	WACOM_TYPE_ERASER  =     (1 << 2),
+	WACOM_TYPE_CURSOR  =     (1 << 3),
+	WACOM_TYPE_PAD     =     (1 << 4),
+	WACOM_TYPE_TOUCH   =     (1 << 5),
+	WACOM_TYPE_ALL     =     WACOM_TYPE_STYLUS | WACOM_TYPE_ERASER | WACOM_TYPE_CURSOR | WACOM_TYPE_PAD | WACOM_TYPE_TOUCH
+} GsdWacomDeviceType;
+
+GType		  gsd_wacom_device_get_type		(void);
+
+void		  gsd_wacom_device_set_display		(GsdWacomDevice	*device,
+							 int		 monitor);
+gint		  gsd_wacom_device_get_display_monitor	(GsdWacomDevice	*device);
+gboolean	  gsd_wacom_device_get_display_matrix	(GsdWacomDevice	*device,
+							 float		 matrix[NUM_ELEMS_MATRIX]);
+
+GsdWacomDevice	* gsd_wacom_device_new			(XDeviceInfo	*device);
+GList		* gsd_wacom_device_list_styli		(GsdWacomDevice	*device);
+const char	* gsd_wacom_device_get_name		(GsdWacomDevice	*device);
+const char	* gsd_wacom_device_get_icon_name	(GsdWacomDevice	*device);
+const char	* gsd_wacom_device_get_tool_name	(GsdWacomDevice	*device);
+gboolean	  gsd_wacom_device_reversible		(GsdWacomDevice	*device);
+gboolean	  gsd_wacom_device_is_screen_tablet	(GsdWacomDevice	*device);
+const char	* gsd_wacom_device_get_settings_path	(GsdWacomDevice	*device);
+const char	* gsd_wacom_device_get_schemas_path	(GsdWacomDevice	*device);
+void		  gsd_wacom_device_set_current_stylus	(GsdWacomDevice *device,
+							 int		 stylus_id);
+GsdWacomStylus	* gsd_wacom_device_get_stylus_for_type	(GsdWacomDevice	*device,
+							 GsdWacomStylusType  type);
+GsdWacomStylus	* gsd_wacom_device_get_stylus_for_path	(GsdWacomDevice	*device,
+							 const char	*settings_path);
+
+GsdWacomDeviceType gsd_wacom_device_get_device_type	(GsdWacomDevice	*device);
+gint		* gsd_wacom_device_get_area		(GsdWacomDevice	*device);
+const char	* gsd_wacom_device_type_to_string	(GsdWacomDeviceType type);
+GList		* gsd_wacom_device_get_buttons		(GsdWacomDevice	*device);
+GsdWacomTabletButton *gsd_wacom_device_get_button	(GsdWacomDevice	*device,
+							 int		 button,
+							 GtkDirectionType *dir);
+int gsd_wacom_device_set_next_mode			(GsdWacomDevice *device,
+							 int		 group_id);
+/* Helper and debug functions */
+GsdWacomDevice * gsd_wacom_device_create_fake		(GsdWacomDeviceType type,
+							 const char	*name,
+							 const char	*tool_name);
+
+GList 		* gsd_wacom_device_create_fake_cintiq	(void);
+GList 		* gsd_wacom_device_create_fake_bt	(void);
+GList 		* gsd_wacom_device_create_fake_x201	(void);
+GList 		* gsd_wacom_device_create_fake_intuos4	(void);
+
+/* Some additional helper functions that can be shared with g-c-c */
+
+GsdWacomActionType gsd_wacom_get_action_type_from_name   (const char *);
+GsdWacomRotation   gsd_wacom_get_rotation_type_from_name (const char *);
+const char	*gsd_wacom_get_action_name_from_type   (GsdWacomActionType);
+const char	*gsd_wacom_get_rotation_name_from_type (GsdWacomRotation);
+
+G_END_DECLS
+
+#endif /* __GSD_WACOM_DEVICE_MANAGER_H */
diff -up gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-devmanager-helpers.c.wacom gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-devmanager-helpers.c
--- gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-devmanager-helpers.c.wacom	2012-03-05 16:52:15.279449922 -0500
+++ gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-devmanager-helpers.c	2012-03-05 16:52:15.279449922 -0500
@@ -0,0 +1,330 @@
+/*
+ * Copyright (C) 2012 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Author: Olivier Fourdan <ofourdan@redhat.com>
+ */
+
+#include "config.h"
+
+#include "gsd-wacom-devmanager-helpers.h"
+#include <gdk/gdk.h>
+#include <gdk/gdkx.h>
+
+#define GSD_DEVICE_MANAGER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GSD_TYPE_DEVICE_MANAGER, GsdDeviceManagerPrivate))
+
+struct _GsdDeviceManagerPrivate
+{
+	GHashTable *devices;
+	gint opcode;
+};
+
+enum {
+	DEVICE_ADDED,
+	DEVICE_REMOVED,
+	LAST_SIGNAL
+};
+
+static guint signals [LAST_SIGNAL] = { 0 };
+
+G_DEFINE_TYPE (GsdDeviceManager, gsd_device_manager, G_TYPE_OBJECT)
+
+static GsdDeviceType
+get_device_type (XDeviceInfo *dev)
+{
+	g_return_val_if_fail (dev != NULL, GSD_DEVICE_TYPE_FLOATING);
+	switch (dev->use)
+	{
+		case XIMasterKeyboard:
+		case XIMasterPointer:
+			return GSD_DEVICE_TYPE_MASTER;
+			break;
+		case XISlaveKeyboard:
+		case XISlavePointer:
+			return GSD_DEVICE_TYPE_SLAVE;
+			break;
+		case XIFloatingSlave:
+		default:
+			return GSD_DEVICE_TYPE_FLOATING;
+			break;
+	}
+	return GSD_DEVICE_TYPE_FLOATING;
+}
+
+static void
+add_device (GsdDeviceManager	*device_manager,
+	    XDeviceInfo		*device_info,
+	    gboolean		 emit_signal)
+{
+	gpointer dev;
+
+	g_return_if_fail (device_info != NULL);
+
+	if (g_hash_table_lookup (device_manager->priv->devices, GINT_TO_POINTER (device_info->id)))
+		return; /* Already listed */
+
+	dev = g_memdup (device_info, sizeof (XDeviceInfo));
+	((XDeviceInfo *) dev)->name = g_strdup (device_info->name);
+	g_hash_table_insert (device_manager->priv->devices, GINT_TO_POINTER (device_info->id), dev);
+
+	if (emit_signal)
+		g_signal_emit_by_name (device_manager, "device-added", dev);
+}
+
+static void
+remove_device (GsdDeviceManager		*device_manager,
+	       gint			 device_id)
+{
+	gpointer dev;
+
+	dev = g_hash_table_lookup (device_manager->priv->devices, GINT_TO_POINTER (device_id));
+
+	if (dev == NULL)
+		return; /* Not listed */
+
+	g_signal_emit_by_name (device_manager, "device-removed", dev);
+	g_free (((XDeviceInfo *) dev)->name);
+	g_hash_table_remove (device_manager->priv->devices, GINT_TO_POINTER (device_id));
+}
+
+static void
+device_list_create (GsdDeviceManager *device_manager)
+{
+	GdkDisplay *display;
+	Display *xdisplay;
+	XDeviceInfo *device_info;
+	gint n_devices;
+	gint i;
+
+	display = gdk_display_get_default ();
+	xdisplay = GDK_DISPLAY_XDISPLAY (display);
+	device_info = XListInputDevices (xdisplay, &n_devices);
+
+	for (i = 0; i < n_devices; i++)
+		add_device (device_manager, &device_info[i], FALSE);
+
+	if (device_info != NULL)
+		XFreeDeviceList (device_info);
+}
+
+static void
+device_list_changed (GsdDeviceManager		*device_manager,
+		     XDevicePresenceNotifyEvent	*ev)
+{
+	GdkDisplay *display;
+	Display *xdisplay;
+	XDeviceInfo *device_info;
+	gint n_devices;
+	gint i;
+
+	display = gdk_display_get_default ();
+	xdisplay = GDK_DISPLAY_XDISPLAY (display);
+	device_info = XListInputDevices (xdisplay, &n_devices);
+
+	for (i = 0; i < n_devices; i++) {
+		if (ev->devchange == DeviceEnabled) {
+			if (ev->deviceid == device_info[i].id)
+				add_device (device_manager, &device_info[i], TRUE);
+		} else
+			remove_device (device_manager, ev->deviceid);
+	}
+
+	if (device_info != NULL)
+		XFreeDeviceList (device_info);
+}
+
+static GdkFilterReturn
+device_list_filter (GdkXEvent		*xevent,
+		    GdkEvent		*event,
+		    GsdDeviceManager	*device_manager)
+{
+	XEvent *xev = (XEvent *) xevent;
+	XEventClass class_presence;
+	int xi_presence;
+	GdkDisplay *display;
+	Display *xdisplay;
+
+	display = gdk_display_get_default ();
+	xdisplay = GDK_DISPLAY_XDISPLAY (display);
+
+	DevicePresence (xdisplay, xi_presence, class_presence);
+
+	if (xev->type == xi_presence) {
+		device_list_changed (device_manager, (XDevicePresenceNotifyEvent *) xev);
+		return GDK_FILTER_REMOVE;
+	}
+
+	return GDK_FILTER_CONTINUE;
+}
+
+
+static GObject *
+gsd_device_manager_constructor (GType			 type,
+				guint			 n_construct_properties,
+				GObjectConstructParam	*construct_properties)
+{
+	GsdDeviceManager      *device_manager;
+	int opcode, firstevent, firsterror;
+	GdkDisplay *display;
+	Display *xdisplay;
+	XEventClass class_presence;
+	int xi_presence;
+
+	device_manager = GSD_DEVICE_MANAGER (G_OBJECT_CLASS (gsd_device_manager_parent_class)->constructor (type,
+													    n_construct_properties,
+													    construct_properties));
+
+	display = gdk_display_get_default ();
+	xdisplay = GDK_DISPLAY_XDISPLAY (display);
+	device_manager->priv->opcode = 0;
+
+	if (XQueryExtension (xdisplay,
+			     "XInputExtension",
+			     &opcode,
+			     &firstevent,
+			     &firsterror)) {
+		int major, minor;
+		major = 2;
+		minor = 0;
+
+		if (XIQueryVersion (xdisplay, &major, &minor) != BadRequest)
+			device_manager->priv->opcode = opcode;
+	}
+
+	device_list_create (device_manager);
+
+	gdk_error_trap_push ();
+	DevicePresence (xdisplay, xi_presence, class_presence);
+	XSelectExtensionEvent (xdisplay,
+			       RootWindow (xdisplay, DefaultScreen (xdisplay)),
+			       &class_presence, 1);
+
+	gdk_flush ();
+	if (!gdk_error_trap_pop ())
+		gdk_window_add_filter (NULL,
+				       (GdkFilterFunc) device_list_filter,
+				       device_manager);
+
+	return G_OBJECT (device_manager);
+}
+
+static void
+gsd_device_manager_dispose (GObject *object)
+{
+	GsdDeviceManager      *device_manager;
+
+	device_manager = GSD_DEVICE_MANAGER (object);
+	gdk_window_remove_filter (NULL,
+				  (GdkFilterFunc) device_list_filter,
+				  device_manager);
+
+	g_hash_table_destroy (device_manager->priv->devices);
+	device_manager->priv->devices = NULL;
+
+	G_OBJECT_CLASS (gsd_device_manager_parent_class)->dispose (object);
+}
+
+static void
+gsd_device_manager_class_init (GsdDeviceManagerClass *klass)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+	object_class->constructor	= gsd_device_manager_constructor;
+	object_class->dispose		= gsd_device_manager_dispose;
+
+	g_type_class_add_private (klass, sizeof (GsdDeviceManagerPrivate));
+
+	signals [DEVICE_ADDED] =
+		g_signal_new (g_intern_static_string ("device-added"),
+			      G_TYPE_FROM_CLASS (klass),
+			      G_SIGNAL_RUN_LAST,
+			      G_STRUCT_OFFSET (GsdDeviceManagerClass, device_added),
+			      NULL, NULL,
+			      g_cclosure_marshal_VOID__OBJECT,
+			      G_TYPE_NONE, 1,
+			      G_TYPE_POINTER);
+
+	signals [DEVICE_REMOVED] =
+		g_signal_new (g_intern_static_string ("device-removed"),
+			      G_TYPE_FROM_CLASS (klass),
+			      G_SIGNAL_RUN_LAST,
+			      G_STRUCT_OFFSET (GsdDeviceManagerClass, device_removed),
+			      NULL, NULL,
+			      g_cclosure_marshal_VOID__OBJECT,
+			      G_TYPE_NONE, 1,
+			      G_TYPE_POINTER);
+}
+
+static void
+gsd_device_manager_init (GsdDeviceManager *device_manager)
+{
+	device_manager->priv = GSD_DEVICE_MANAGER_GET_PRIVATE (device_manager);
+	device_manager->priv->devices = g_hash_table_new_full (g_direct_hash,
+							       g_direct_equal,
+							       NULL, g_free);
+	device_manager->priv->opcode  = 0;
+}
+
+GsdDeviceManager *
+gsd_display_get_device_manager (GdkDisplay *display)
+{
+	GsdDeviceManager *device_manager;
+
+	g_return_val_if_fail (GDK_IS_DISPLAY (display), NULL);
+
+	device_manager = g_object_get_data (G_OBJECT (display), "device-manager");
+	if (!device_manager) {
+		device_manager = GSD_DEVICE_MANAGER (g_object_new (GSD_TYPE_DEVICE_MANAGER, NULL));
+		g_object_set_data (G_OBJECT (display), "device-manager", device_manager);
+	}
+
+	return device_manager;
+}
+
+GsdDeviceManager *
+gsd_device_manager_new (void)
+{
+	return gsd_display_get_device_manager (gdk_display_get_default ());
+}
+
+GList *
+gsd_device_manager_list_devices (GsdDeviceManager *device_manager,
+				 GsdDeviceType     type)
+{
+	GList *cur, *devices, *list = NULL;
+
+	g_return_val_if_fail (GSD_IS_DEVICE_MANAGER (device_manager), NULL);
+
+	devices = g_hash_table_get_values (device_manager->priv->devices);
+	for (cur = devices; cur; cur = cur->next) {
+		XDeviceInfo *device_info = (XDeviceInfo *) cur->data;
+
+		if (type == get_device_type (device_info))
+			list = g_list_prepend (list, device_info);
+	}
+	g_list_free (devices);
+
+	return list;
+}
+
+gint
+gsd_device_manager_get_opcode (GsdDeviceManager *device_manager)
+{
+	g_return_val_if_fail (GSD_IS_DEVICE_MANAGER (device_manager), 0);
+
+	return device_manager->priv->opcode;
+}
+
diff -up gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-devmanager-helpers.h.wacom gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-devmanager-helpers.h
--- gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-devmanager-helpers.h.wacom	2012-03-05 16:52:15.279449922 -0500
+++ gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-devmanager-helpers.h	2012-03-05 16:52:15.279449922 -0500
@@ -0,0 +1,80 @@
+/*
+ * GDK - The GIMP Drawing Kit
+ * Copyright (C) 2009 Carlos Garnacho <carlosg@gnome.org>
+ * Copyright (C) 2012 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Author: Olivier Fourdan <ofourdan@redhat.com>
+ */
+
+#ifndef __GSD_DEVICE_MANAGER_H__
+#define __GSD_DEVICE_MANAGER_H__
+
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/extensions/XInput.h>
+#include <X11/extensions/XInput2.h>
+#include <X11/extensions/XIproto.h>
+
+#include <glib-object.h>
+#include <glib.h>
+#include <gdk/gdktypes.h>
+
+G_BEGIN_DECLS
+
+#define GSD_TYPE_DEVICE_MANAGER		(gsd_device_manager_get_type ())
+#define GSD_DEVICE_MANAGER(o)		(G_TYPE_CHECK_INSTANCE_CAST ((o), GSD_TYPE_DEVICE_MANAGER, GsdDeviceManager))
+#define GSD_DEVICE_MANAGER_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), GSD_TYPE_DEVICE_MANAGER, GsdDeviceManagerClass))
+#define GSD_IS_DEVICE_MANAGER(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), GSD_TYPE_DEVICE_MANAGER))
+#define GSD_IS_DEVICE_MANAGER_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), GSD_TYPE_DEVICE_MANAGER))
+#define GSD_DEVICE_MANAGER_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), GSD_TYPE_DEVICE_MANAGER, GsdDeviceManagerClass))
+
+typedef enum {
+	GSD_DEVICE_TYPE_MASTER,
+	GSD_DEVICE_TYPE_SLAVE,
+	GSD_DEVICE_TYPE_FLOATING
+} GsdDeviceType;
+
+typedef struct _GsdDeviceManagerPrivate GsdDeviceManagerPrivate;
+
+typedef struct
+{
+	GObject			 parent;
+	GsdDeviceManagerPrivate	*priv;
+} GsdDeviceManager;
+
+typedef struct
+{
+	GObjectClass   parent_class;
+
+	/* Signals */
+	void (* device_added)	(GsdDeviceManager	*device_manager,
+				 gconstpointer		 device_info);
+	void (* device_removed)	(GsdDeviceManager	*device_manager,
+				 gconstpointer		 device_info);
+} GsdDeviceManagerClass;
+
+GType			gsd_device_manager_get_type		(void) G_GNUC_CONST;
+GsdDeviceManager *	gsd_display_get_device_manager		(GdkDisplay *);
+GsdDeviceManager *	gsd_device_manager_new			(void);
+GList *			gsd_device_manager_list_devices		(GsdDeviceManager *,
+								 GsdDeviceType);
+gint			gsd_device_manager_get_opcode		(GsdDeviceManager *);
+
+G_END_DECLS
+
+#endif /* __GSD_DEVICE_MANAGER_H__ */
+
diff -up gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-gconf-helpers.c.wacom gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-gconf-helpers.c
--- gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-gconf-helpers.c.wacom	2012-03-05 16:52:15.280475289 -0500
+++ gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-gconf-helpers.c	2012-03-05 16:52:15.280475289 -0500
@@ -0,0 +1,279 @@
+/*
+ * Copyright (C) 2012 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Author: Olivier Fourdan <ofourdan@redhat.com>
+ */
+
+#include "config.h"
+
+#include "gsd-wacom-gconf-helpers.h"
+
+gchar *
+gsd_gconf_build_path (const char *path, const char *key)
+{
+	g_return_val_if_fail (path != NULL, NULL);
+	g_return_val_if_fail (key != NULL, NULL);
+
+	return g_strdup_printf ("%s/%s", path, key);
+}
+
+GConfValue *
+gsd_gconf_get (const char *settings_path, const char *schemas_path, const char *key)
+{
+	GConfEngine *engine;
+	GConfClient *client;
+	GConfValue *value;
+	gchar *key_path;
+
+	g_return_val_if_fail (settings_path != NULL, NULL);
+	g_return_val_if_fail (schemas_path != NULL, NULL);
+	g_return_val_if_fail (key != NULL, NULL);
+
+	key_path = gsd_gconf_build_path (settings_path, key);
+	engine = gconf_engine_get_default ();
+	client = gconf_client_get_for_engine (engine);
+	value = gconf_client_get (client, key_path, NULL);
+
+	if (value == NULL) {
+		gchar *schema_key_path;
+
+		gconf_client_clear_cache (client);
+		schema_key_path = gsd_gconf_build_path (schemas_path, key);
+		gconf_engine_associate_schema (engine, key_path, schema_key_path, NULL);
+		g_free (schema_key_path);
+
+		/* Retry now */
+		value = gconf_client_get (client, key_path, NULL);
+	}
+	g_object_unref (client);
+	g_free (key_path);
+
+	return value;
+}
+
+gboolean
+gsd_gconf_set (const char *settings_path, const char *key, GConfValue *value)
+{
+	GConfEngine *engine;
+	GConfClient *client;
+	gchar *key_path;
+	GError *error = NULL;
+
+	g_return_val_if_fail (settings_path != NULL, FALSE);
+	g_return_val_if_fail (key != NULL, FALSE);
+	g_return_val_if_fail (value != NULL, FALSE);
+
+	key_path = gsd_gconf_build_path (settings_path, key);
+	engine = gconf_engine_get_default ();
+	client = gconf_client_get_for_engine (engine);
+	gconf_client_set (client, key_path, value, &error);
+	g_object_unref (client);
+	g_free (key_path);
+
+	if (error != NULL) {
+		g_warning ("GConf: %s", error->message);
+		g_error_free (error);
+		return FALSE;
+	}
+	return TRUE;
+}
+
+gchar **
+gsd_gconf_value_get_strv (GConfValue *value, gsize *len)
+{
+	GSList *value_list = NULL, *slist;
+	gchar **str_array;
+	gsize n = 0, i = 0;
+
+	g_return_val_if_fail (value != NULL, NULL);
+	g_return_val_if_fail (value->type == GCONF_VALUE_LIST, NULL);
+	g_return_val_if_fail (gconf_value_get_list_type (value) == GCONF_VALUE_STRING, NULL);
+
+	value_list = gconf_value_get_list (value);
+	n = g_slist_length (value_list);
+	str_array = g_new (gchar *, n + 1);
+	str_array[n] = NULL;
+
+	if (len != NULL)
+		*len = n;
+
+	for (slist = value_list, i = 0; slist; slist = slist->next)
+		str_array[i++] = g_strdup(gconf_value_get_string (slist->data));
+
+	return str_array;
+}
+
+gsize
+gsd_gconf_value_set_strv (GConfValue *value, const gchar * const *str_array)
+{
+	GSList *value_list = NULL;
+	GConfValue *v;
+	gsize i = 0;
+
+	g_return_val_if_fail (str_array != NULL, 0);
+	g_return_val_if_fail (value != NULL, 0);
+	g_return_val_if_fail (value->type == GCONF_VALUE_LIST, 0);
+	g_return_val_if_fail (gconf_value_get_list_type (value) == GCONF_VALUE_STRING, 0);
+
+	i = 0;
+	while (str_array[i]) {
+		v = gconf_value_new (GCONF_VALUE_STRING);
+		gconf_value_set_string (v, str_array[i++]);
+		value_list = g_slist_append (value_list, v);
+	}
+	gconf_value_set_list (value, value_list);
+	g_slist_free (value_list);
+
+	return i;
+}
+
+int *
+gsd_gconf_value_get_int_array (GConfValue *value, gsize *len)
+{
+	GSList *value_list = NULL, *slist;
+	int *int_array;
+	gsize n = 0, i = 0;
+
+	g_return_val_if_fail (value != NULL, NULL);
+	g_return_val_if_fail (value->type == GCONF_VALUE_LIST, NULL);
+	g_return_val_if_fail (gconf_value_get_list_type (value) == GCONF_VALUE_INT, NULL);
+
+	value_list = gconf_value_get_list (value);
+	n = g_slist_length (value_list);
+	int_array = g_new (int, n);
+
+	if (len != NULL)
+		*len = n;
+
+	for (slist = value_list, i = 0; slist; slist = slist->next)
+		int_array[i++] = gconf_value_get_int (slist->data);
+
+	return int_array;
+}
+
+gsize
+gsd_gconf_value_set_int_array (GConfValue *value, const int *int_array, gsize len)
+{
+	GSList *value_list = NULL;
+	GConfValue *v;
+	gsize i;
+
+	g_return_val_if_fail (int_array != NULL, 0);
+	g_return_val_if_fail (value != NULL, 0);
+	g_return_val_if_fail (value->type == GCONF_VALUE_LIST, 0);
+	g_return_val_if_fail (gconf_value_get_list_type (value) == GCONF_VALUE_INT, 0);
+
+	for (i = 0; i < len; i++) {
+		v = gconf_value_new (GCONF_VALUE_INT);
+		gconf_value_set_int (v, int_array[i]);
+		value_list = g_slist_append (value_list, v);
+	}
+	gconf_value_set_list_nocopy(value, value_list);
+
+	return i;
+}
+
+gboolean
+gsd_gconf_set_string (const char *settings_path, const char *key, const char *str)
+{
+	GConfValue *value;
+	gboolean ret;
+
+	g_return_val_if_fail (settings_path != NULL, FALSE);
+	g_return_val_if_fail (key != NULL, FALSE);
+	g_return_val_if_fail (str != NULL, FALSE);
+
+	value = gconf_value_new (GCONF_VALUE_STRING);
+	gconf_value_set_string (value, str);
+	ret = gsd_gconf_set (settings_path, key, value);
+	gconf_value_free (value);
+
+	return ret;
+}
+
+gboolean
+gsd_gconf_set_int (const char *settings_path, const char *key, int i)
+{
+	GConfValue *value;
+	gboolean ret;
+
+	g_return_val_if_fail (settings_path != NULL, FALSE);
+	g_return_val_if_fail (key != NULL, FALSE);
+
+	value = gconf_value_new (GCONF_VALUE_INT);
+	gconf_value_set_int (value, i);
+	ret = gsd_gconf_set (settings_path, key, value);
+	gconf_value_free (value);
+
+	return ret;
+}
+
+gboolean
+gsd_gconf_set_boolean (const char *settings_path, const char *key, gboolean b)
+{
+	GConfValue *value;
+	gboolean ret;
+
+	g_return_val_if_fail (settings_path != NULL, FALSE);
+	g_return_val_if_fail (key != NULL, FALSE);
+
+	value = gconf_value_new (GCONF_VALUE_BOOL);
+	gconf_value_set_bool (value, b);
+	ret = gsd_gconf_set (settings_path, key, value);
+	gconf_value_free (value);
+
+	return ret;
+}
+
+gboolean
+gsd_gconf_set_strv (const char *settings_path, const char *key, const gchar * const *str_array)
+{
+	GConfValue *value;
+	gboolean ret;
+
+	g_return_val_if_fail (settings_path != NULL, FALSE);
+	g_return_val_if_fail (key != NULL, FALSE);
+	g_return_val_if_fail (str_array != NULL, FALSE);
+
+	value = gconf_value_new (GCONF_VALUE_LIST);
+	gconf_value_set_list_type (value, GCONF_VALUE_STRING);
+	gsd_gconf_value_set_strv (value, str_array);
+	ret = gsd_gconf_set (settings_path, key, value);
+	gconf_value_free (value);
+
+	return ret;
+}
+
+gboolean
+gsd_gconf_set_int_array (const char *settings_path, const char *key, const int *int_array)
+{
+	GConfValue *value;
+	gboolean ret;
+
+	g_return_val_if_fail (settings_path != NULL, FALSE);
+	g_return_val_if_fail (key != NULL, FALSE);
+	g_return_val_if_fail (int_array != NULL, FALSE);
+
+
+	value = gconf_value_new (GCONF_VALUE_LIST);
+	gconf_value_set_list_type (value, GCONF_VALUE_INT);
+	gsd_gconf_value_set_int_array (value, int_array, G_N_ELEMENTS (int_array));
+	ret = gsd_gconf_set (settings_path, key, value);
+	gconf_value_free (value);
+
+	return ret;
+}
diff -up gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-gconf-helpers.h.wacom gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-gconf-helpers.h
--- gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-gconf-helpers.h.wacom	2012-03-05 16:52:15.280475289 -0500
+++ gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-gconf-helpers.h	2012-03-05 16:52:15.280475289 -0500
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2012 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Author: Olivier Fourdan <ofourdan@redhat.com>
+ */
+
+#ifndef __GSD_GCONF_HELPERS_H__
+#define __GSD_GCONF_HELPERS_H__
+
+#include <glib.h>
+#include <gconf/gconf.h>
+#include <gconf/gconf-value.h>
+#include <gconf/gconf-client.h>
+
+G_BEGIN_DECLS
+
+gchar *		gsd_gconf_build_path		(const char *,
+						 const char *);
+GConfValue *	gsd_gconf_get			(const char *,
+						 const char *,
+						 const char *);
+gboolean	gsd_gconf_set 			(const char *,
+						 const char *,
+						 GConfValue *);
+gchar **	gsd_gconf_value_get_strv	(GConfValue *,
+						 gsize *len);
+gsize		gsd_gconf_value_set_strv	(GConfValue *,
+						 const gchar * const*);
+int *		gsd_gconf_value_get_int_array	(GConfValue *,
+						 gsize *);
+gsize		gsd_gconf_value_set_int_array	(GConfValue *,
+						 const int *,
+						 gsize);
+gboolean	gsd_gconf_set_string		(const char *,
+						 const char *,
+						 const char *);
+gboolean	gsd_gconf_set_int		(const char *,
+						 const char *,
+						 int);
+gboolean	gsd_gconf_set_boolean		(const char *,
+						 const char *,
+						 gboolean);
+gboolean	gsd_gconf_set_strv		(const char *,
+						 const char *,
+						 const gchar * const*);
+gboolean	gsd_gconf_set_int_array		(const char *,
+						 const char *,
+						 const int *);
+
+G_END_DECLS
+
+#endif /* __GSD_GCONF_HELPERS_H__ */
diff -up gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-gdk-helpers.c.wacom gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-gdk-helpers.c
--- gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-gdk-helpers.c.wacom	2012-03-05 16:52:15.281476681 -0500
+++ gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-gdk-helpers.c	2012-03-05 16:52:15.281476681 -0500
@@ -0,0 +1,381 @@
+/*
+ * GTK - The GIMP Toolkit
+ * Copyright (C) 1998, 2001 Tim Janik
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <string.h>
+#include <stdlib.h>
+
+#include "gsd-wacom-gdk-helpers.h"
+
+static inline gboolean
+is_alt (const gchar *string)
+{
+  return ((string[0] == '<') &&
+	  (string[1] == 'a' || string[1] == 'A') &&
+	  (string[2] == 'l' || string[2] == 'L') &&
+	  (string[3] == 't' || string[3] == 'T') &&
+	  (string[4] == '>'));
+}
+
+static inline gboolean
+is_ctl (const gchar *string)
+{
+  return ((string[0] == '<') &&
+	  (string[1] == 'c' || string[1] == 'C') &&
+	  (string[2] == 't' || string[2] == 'T') &&
+	  (string[3] == 'l' || string[3] == 'L') &&
+	  (string[4] == '>'));
+}
+
+static inline gboolean
+is_modx (const gchar *string)
+{
+  return ((string[0] == '<') &&
+	  (string[1] == 'm' || string[1] == 'M') &&
+	  (string[2] == 'o' || string[2] == 'O') &&
+	  (string[3] == 'd' || string[3] == 'D') &&
+	  (string[4] >= '1' && string[4] <= '5') &&
+	  (string[5] == '>'));
+}
+
+static inline gboolean
+is_ctrl (const gchar *string)
+{
+  return ((string[0] == '<') &&
+	  (string[1] == 'c' || string[1] == 'C') &&
+	  (string[2] == 't' || string[2] == 'T') &&
+	  (string[3] == 'r' || string[3] == 'R') &&
+	  (string[4] == 'l' || string[4] == 'L') &&
+	  (string[5] == '>'));
+}
+
+static inline gboolean
+is_shft (const gchar *string)
+{
+  return ((string[0] == '<') &&
+	  (string[1] == 's' || string[1] == 'S') &&
+	  (string[2] == 'h' || string[2] == 'H') &&
+	  (string[3] == 'f' || string[3] == 'F') &&
+	  (string[4] == 't' || string[4] == 'T') &&
+	  (string[5] == '>'));
+}
+
+static inline gboolean
+is_shift (const gchar *string)
+{
+  return ((string[0] == '<') &&
+	  (string[1] == 's' || string[1] == 'S') &&
+	  (string[2] == 'h' || string[2] == 'H') &&
+	  (string[3] == 'i' || string[3] == 'I') &&
+	  (string[4] == 'f' || string[4] == 'F') &&
+	  (string[5] == 't' || string[5] == 'T') &&
+	  (string[6] == '>'));
+}
+
+static inline gboolean
+is_control (const gchar *string)
+{
+  return ((string[0] == '<') &&
+	  (string[1] == 'c' || string[1] == 'C') &&
+	  (string[2] == 'o' || string[2] == 'O') &&
+	  (string[3] == 'n' || string[3] == 'N') &&
+	  (string[4] == 't' || string[4] == 'T') &&
+	  (string[5] == 'r' || string[5] == 'R') &&
+	  (string[6] == 'o' || string[6] == 'O') &&
+	  (string[7] == 'l' || string[7] == 'L') &&
+	  (string[8] == '>'));
+}
+
+static inline gboolean
+is_release (const gchar *string)
+{
+  return ((string[0] == '<') &&
+	  (string[1] == 'r' || string[1] == 'R') &&
+	  (string[2] == 'e' || string[2] == 'E') &&
+	  (string[3] == 'l' || string[3] == 'L') &&
+	  (string[4] == 'e' || string[4] == 'E') &&
+	  (string[5] == 'a' || string[5] == 'A') &&
+	  (string[6] == 's' || string[6] == 'S') &&
+	  (string[7] == 'e' || string[7] == 'E') &&
+	  (string[8] == '>'));
+}
+
+static inline gboolean
+is_meta (const gchar *string)
+{
+  return ((string[0] == '<') &&
+	  (string[1] == 'm' || string[1] == 'M') &&
+	  (string[2] == 'e' || string[2] == 'E') &&
+	  (string[3] == 't' || string[3] == 'T') &&
+	  (string[4] == 'a' || string[4] == 'A') &&
+	  (string[5] == '>'));
+}
+
+static inline gboolean
+is_super (const gchar *string)
+{
+  return ((string[0] == '<') &&
+	  (string[1] == 's' || string[1] == 'S') &&
+	  (string[2] == 'u' || string[2] == 'U') &&
+	  (string[3] == 'p' || string[3] == 'P') &&
+	  (string[4] == 'e' || string[4] == 'E') &&
+	  (string[5] == 'r' || string[5] == 'R') &&
+	  (string[6] == '>'));
+}
+
+static inline gboolean
+is_hyper (const gchar *string)
+{
+  return ((string[0] == '<') &&
+	  (string[1] == 'h' || string[1] == 'H') &&
+	  (string[2] == 'y' || string[2] == 'Y') &&
+	  (string[3] == 'p' || string[3] == 'P') &&
+	  (string[4] == 'e' || string[4] == 'E') &&
+	  (string[5] == 'r' || string[5] == 'R') &&
+	  (string[6] == '>'));
+}
+
+static inline gboolean
+is_keycode (const gchar *string)
+{
+  return (string[0] == '0' &&
+	  string[1] == 'x' &&
+	  g_ascii_isxdigit (string[2]) &&
+	  g_ascii_isxdigit (string[3]));
+}
+
+void
+gsd_accelerator_parse_with_keycode (const gchar     *accelerator,
+				    guint	   *accelerator_key,
+				    guint	  **accelerator_codes,
+				    GdkModifierType *accelerator_mods)
+{
+  guint keyval;
+  GdkModifierType mods;
+  gint len;
+  gboolean error;
+
+  if (accelerator_key)
+    *accelerator_key = 0;
+  if (accelerator_mods)
+    *accelerator_mods = 0;
+  if (accelerator_codes)
+    *accelerator_codes = NULL;
+  g_return_if_fail (accelerator != NULL);
+
+  error = FALSE;
+  keyval = 0;
+  mods = 0;
+  len = strlen (accelerator);
+  while (len)
+    {
+      if (*accelerator == '<')
+	{
+	  if (len >= 9 && is_release (accelerator))
+	    {
+	      accelerator += 9;
+	      len -= 9;
+	      mods |= GDK_RELEASE_MASK;
+	    }
+	  else if (len >= 9 && is_control (accelerator))
+	    {
+	      accelerator += 9;
+	      len -= 9;
+	      mods |= GDK_CONTROL_MASK;
+	    }
+	  else if (len >= 7 && is_shift (accelerator))
+	    {
+	      accelerator += 7;
+	      len -= 7;
+	      mods |= GDK_SHIFT_MASK;
+	    }
+	  else if (len >= 6 && is_shft (accelerator))
+	    {
+	      accelerator += 6;
+	      len -= 6;
+	      mods |= GDK_SHIFT_MASK;
+	    }
+	  else if (len >= 6 && is_ctrl (accelerator))
+	    {
+	      accelerator += 6;
+	      len -= 6;
+	      mods |= GDK_CONTROL_MASK;
+	    }
+	  else if (len >= 6 && is_modx (accelerator))
+	    {
+	      static const guint mod_vals[] = {
+		GDK_MOD1_MASK, GDK_MOD2_MASK, GDK_MOD3_MASK,
+		GDK_MOD4_MASK, GDK_MOD5_MASK
+	      };
+
+	      len -= 6;
+	      accelerator += 4;
+	      mods |= mod_vals[*accelerator - '1'];
+	      accelerator += 2;
+	    }
+	  else if (len >= 5 && is_ctl (accelerator))
+	    {
+	      accelerator += 5;
+	      len -= 5;
+	      mods |= GDK_CONTROL_MASK;
+	    }
+	  else if (len >= 5 && is_alt (accelerator))
+	    {
+	      accelerator += 5;
+	      len -= 5;
+	      mods |= GDK_MOD1_MASK;
+	    }
+	  else if (len >= 6 && is_meta (accelerator))
+	    {
+	      accelerator += 6;
+	      len -= 6;
+	      mods |= GDK_META_MASK;
+	    }
+	  else if (len >= 7 && is_hyper (accelerator))
+	    {
+	      accelerator += 7;
+	      len -= 7;
+	      mods |= GDK_HYPER_MASK;
+	    }
+	  else if (len >= 7 && is_super (accelerator))
+	    {
+	      accelerator += 7;
+	      len -= 7;
+	      mods |= GDK_SUPER_MASK;
+	    }
+	  else
+	    {
+	      gchar last_ch;
+
+	      last_ch = *accelerator;
+	      while (last_ch && last_ch != '>')
+		{
+		  last_ch = *accelerator;
+		  accelerator += 1;
+		  len -= 1;
+		}
+	    }
+	}
+      else
+	{
+	  if (len >= 4 && is_keycode (accelerator))
+	    {
+	       char keystring[5];
+	       gchar *endptr;
+	       gint tmp_keycode;
+
+	       memcpy (keystring, accelerator, 4);
+	       keystring [4] = '\000';
+
+	       tmp_keycode = strtol (keystring, &endptr, 16);
+
+	       if (endptr == NULL || *endptr != '\000')
+		 {
+		   error = TRUE;
+		   goto out;
+		 }
+	       else if (accelerator_codes != NULL)
+		 {
+		   /* 0x00 is an invalid keycode too. */
+		   if (tmp_keycode == 0)
+		     {
+		       error = TRUE;
+		       goto out;
+		     }
+		   else
+		     {
+		       *accelerator_codes = g_new0 (guint, 2);
+		       (*accelerator_codes)[0] = tmp_keycode;
+		     }
+		 }
+	       else
+		 {
+		   /* There was a keycode in the string, but
+		    * we cannot store it, so we have an error */
+		   error = TRUE;
+		   goto out;
+		 }
+	    }
+	  else
+	    {
+	      keyval = gdk_keyval_from_name (accelerator);
+	      if (keyval == GDK_VoidSymbol)
+		{
+		  error = TRUE;
+		  goto out;
+		}
+	    }
+
+	  if (keyval && accelerator_codes != NULL)
+	    {
+	      GdkKeymapKey *keys;
+	      gint n_keys, i, j;
+
+	      if (!gdk_keymap_get_entries_for_keyval (gdk_keymap_get_default (), keyval, &keys, &n_keys))
+		{
+		  /* Not in keymap */
+		  error = TRUE;
+		  goto out;
+		}
+	      else
+		{
+		  *accelerator_codes = g_new0 (guint, n_keys + 1);
+
+		  /* Prefer level-0 keys to modified keys */
+		  for (i = 0, j = 0; i < n_keys; ++i)
+		    {
+		      if (keys[i].level == 0)
+			(*accelerator_codes)[j++] = keys[i].keycode;
+		    }
+
+		  /* No level-0 keys? Find in the whole keymap */
+		  if (j == 0)
+		    {
+		      for (i = 0, j = 0; i < n_keys; ++i)
+			(*accelerator_codes)[j++] = keys[i].keycode;
+		    }
+
+		  if (j == 0)
+		    {
+		      g_free (*accelerator_codes);
+		      *accelerator_codes = NULL;
+		      /* Not in keymap */
+		      error = TRUE;
+		      goto out;
+		    }
+		  g_free (keys);
+		}
+	    }
+
+	  accelerator += len;
+	  len -= len;
+	}
+    }
+
+out:
+  if (error)
+    keyval = mods = 0;
+
+  if (accelerator_key)
+    *accelerator_key = gdk_keyval_to_lower (keyval);
+  if (accelerator_mods)
+    *accelerator_mods = mods;
+}
diff -up gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-gdk-helpers.h.wacom gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-gdk-helpers.h
--- gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-gdk-helpers.h.wacom	2012-03-05 16:52:15.281476681 -0500
+++ gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-gdk-helpers.h	2012-03-05 16:52:15.281476681 -0500
@@ -0,0 +1,39 @@
+/*
+ * GTK - The GIMP Toolkit
+ * Copyright (C) 1998, 2001 Tim Janik
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#ifndef __GSD_WACOM_GDK_HELPERS_H
+#define __GSD_WACOM_GDK_HELPERS_H
+
+#include <glib.h>
+#include <gdk/gdk.h>
+#include <gdk/gdkkeysyms.h>
+
+G_BEGIN_DECLS
+
+void	gsd_accelerator_parse_with_keycode	(const gchar	 *accelerator,
+						 guint		 *accelerator_key,
+						 guint		**accelerator_codes,
+						 GdkModifierType *accelerator_mods);
+
+G_END_DECLS
+
+#endif /* __GSD_WACOM_GDK_HELPERS_H */
diff -up gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-manager.c.wacom gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-manager.c
--- gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-manager.c.wacom	2012-03-05 16:52:15.283474346 -0500
+++ gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-manager.c	2012-03-05 16:52:15.283474346 -0500
@@ -0,0 +1,1243 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 William Jon McCann <mccann@jhu.edu>
+ * Copyright (C) 2010 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+
+#include <locale.h>
+
+#include <glib.h>
+#include <gtk/gtk.h>
+#include <gdk/gdkx.h>
+#include <X11/Xatom.h>
+#include <X11/extensions/XTest.h>
+#include <X11/keysym.h>
+#include <xorg/Xwacom.h>
+
+#include "gnome-settings-profile.h"
+#include "gsd-wacom-manager.h"
+#include "gsd-input-helper.h"
+#include "gsd-keygrab.h"
+#include "gsd-wacom-device.h"
+#include "gsd-wacom-devmanager-helpers.h"
+#include "gsd-wacom-gdk-helpers.h"
+
+#define GSD_WACOM_MANAGER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GSD_TYPE_WACOM_MANAGER, GsdWacomManagerPrivate))
+
+#define GCONF_WACOM_DIR			"/desktop/gnome/peripherals/wacom"
+#define GCONF_WACOM_DIR_SLASH		GCONF_WACOM_DIR "/"
+#define WACOM_DEVICE_CONFIG_BASE	GCONF_WACOM_DIR_SLASH "%s/"
+
+#define KEY_ROTATION			"rotation"
+#define KEY_TOUCH			"touch"
+#define KEY_TPCBUTTON			"tablet-pc-button"
+#define KEY_IS_ABSOLUTE			"is-absolute"
+#define KEY_AREA			"area"
+#define KEY_PAD_BUTTON_MAPPING		"pad-buttonmapping"
+#define KEY_DISPLAY			"display"
+
+/* Stylus and Eraser settings */
+#define KEY_BUTTON_MAPPING		"buttonmapping"
+#define KEY_PRESSURETHRESHOLD		"pressurethreshold"
+#define KEY_PRESSURECURVE		"pressurecurve"
+
+/* Button settings */
+#define KEY_ACTION_TYPE			"action-type"
+#define KEY_CUSTOM_ACTION		"custom-action"
+#define KEY_CUSTOM_ELEVATOR_ACTION	"custom-elevator-action"
+
+/* See "Wacom Pressure Threshold" */
+#define DEFAULT_PRESSURE_THRESHOLD 	27
+
+struct GsdWacomManagerPrivate
+{
+	guint start_idle_id;
+	GsdDeviceManager *device_manager;
+	guint device_added_id;
+	guint device_removed_id;
+	guint notify_wacom;
+	GHashTable *devices; /* key = XDeviceInfo, value = GsdWacomDevice */
+
+	/* button capture */
+	GSList *screens;
+	int      opcode;
+};
+
+static void     gsd_wacom_manager_class_init  (GsdWacomManagerClass *klass);
+static void     gsd_wacom_manager_init	(GsdWacomManager      *wacom_manager);
+static void     gsd_wacom_manager_finalize    (GObject	      *object);
+
+G_DEFINE_TYPE (GsdWacomManager, gsd_wacom_manager, G_TYPE_OBJECT)
+
+static gpointer manager_object = NULL;
+
+static GObject *
+gsd_wacom_manager_constructor (GType		     type,
+			       guint		      n_construct_properties,
+			       GObjectConstructParam     *construct_properties)
+{
+	GsdWacomManager      *wacom_manager;
+
+	wacom_manager = GSD_WACOM_MANAGER (G_OBJECT_CLASS (gsd_wacom_manager_parent_class)->constructor (type,
+													 n_construct_properties,
+													 construct_properties));
+
+	return G_OBJECT (wacom_manager);
+}
+
+static void
+gsd_wacom_manager_dispose (GObject *object)
+{
+	G_OBJECT_CLASS (gsd_wacom_manager_parent_class)->dispose (object);
+}
+
+static void
+gsd_wacom_manager_class_init (GsdWacomManagerClass *klass)
+{
+	GObjectClass   *object_class = G_OBJECT_CLASS (klass);
+
+	object_class->constructor = gsd_wacom_manager_constructor;
+	object_class->dispose = gsd_wacom_manager_dispose;
+	object_class->finalize = gsd_wacom_manager_finalize;
+
+	g_type_class_add_private (klass, sizeof (GsdWacomManagerPrivate));
+}
+
+static int
+get_device_id (GsdWacomDevice *device)
+{
+	XDeviceInfo *device_info;
+	int id;
+
+	g_object_get (device, "device-info", &device_info, NULL);
+	if (device_info == NULL)
+		return -1;
+	id = device_info->id;
+	return id;
+}
+
+static XDevice *
+open_device (GsdWacomDevice *device)
+{
+	XDevice *xdev;
+	int id;
+
+	id = get_device_id (device);
+	if (id < 0)
+		return NULL;
+
+	gdk_error_trap_push ();
+	xdev = XOpenDevice (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), id);
+	if (gdk_error_trap_pop () || (xdev == NULL))
+		return NULL;
+
+	return xdev;
+}
+
+static void
+wacom_set_property (GsdWacomDevice *device,
+		    PropertyHelper *property)
+{
+	XDevice *xdev;
+
+	xdev = open_device (device);
+	device_set_property (xdev, gsd_wacom_device_get_tool_name (device), property);
+	XCloseDevice (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), xdev);
+}
+
+static void
+set_rotation (GsdWacomDevice *device,
+	      GsdWacomRotation rotation)
+{
+	gchar rot = rotation;
+	PropertyHelper property = {
+		.name = "Wacom Rotation",
+		.nitems = 1,
+		.format = 8,
+		.type   = XA_INTEGER,
+		.data.c = &rot,
+	};
+
+	wacom_set_property (device, &property);
+}
+
+static void
+set_pressurecurve (GsdWacomDevice *device,
+		   GConfValue     *value)
+{
+	PropertyHelper property = {
+		.name = "Wacom Pressurecurve",
+		.nitems = 4,
+		.type   = XA_INTEGER,
+		.format = 32,
+	};
+	gsize nvalues;
+	int *int_array;
+
+	int_array = gsd_gconf_value_get_int_array (value, &nvalues);
+	if (nvalues != 4) {
+		g_free (int_array);
+		g_error ("Pressurecurve requires 4 values.");
+		return;
+	}
+
+	property.data.i = int_array;
+	wacom_set_property (device, &property);
+	g_free(int_array);
+}
+
+/* Area handling. Each area is defined as top x/y, bottom x/y and limits the
+ * usable area of the physical device to the given area (in device coords)
+ */
+static void
+set_area (GsdWacomDevice  *device,
+	  GConfValue      *value)
+{
+	PropertyHelper property = {
+		.name = "Wacom Tablet Area",
+		.nitems = 4,
+		.type   = XA_INTEGER,
+		.format = 32,
+	};
+	gsize nvalues;
+	int *int_array;
+
+	int_array = gsd_gconf_value_get_int_array (value, &nvalues);
+	if (nvalues != 4) {
+		g_error ("Area configuration requires 4 values, got %i.", (gint) nvalues);
+		return;
+	}
+
+	property.data.i = int_array;
+	wacom_set_property (device, &property);
+	g_free(int_array);
+}
+
+static void
+set_display (GsdWacomDevice  *device,
+	     GConfValue      *value)
+{
+	float matrix[NUM_ELEMS_MATRIX];
+	PropertyHelper property = {
+		.name   = "Coordinate Transformation Matrix",
+		.nitems = NUM_ELEMS_MATRIX,
+		.format = 32,
+		.type   = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), "FLOAT", True),
+	};
+
+	gsd_wacom_device_get_display_matrix (device, matrix);
+
+	property.data.i = (gint*)(&matrix);
+	g_debug ("Applying matrix to device...");
+	wacom_set_property (device, &property);
+}
+
+static void
+set_absolute (GsdWacomDevice  *device,
+	      gint	     is_absolute)
+{
+	XDevice *xdev;
+
+	xdev = open_device (device);
+	gdk_error_trap_push ();
+	XSetDeviceMode (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), xdev, is_absolute ? Absolute : Relative);
+	if (gdk_error_trap_pop ())
+		g_error ("Failed to set mode \"%s\" for \"%s\".",
+			 is_absolute ? "Absolute" : "Relative", gsd_wacom_device_get_tool_name (device));
+	XCloseDevice (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), xdev);
+}
+
+static void
+set_device_buttonmap (GsdWacomDevice *device,
+		      GConfValue      *value)
+{
+	XDevice *xdev;
+	gsize nmap;
+	gint *intmap;
+	unsigned char *map;
+	int i, j, rc;
+
+	xdev = open_device (device);
+
+	intmap = gsd_gconf_value_get_int_array (value, &nmap);
+	map = g_new0 (unsigned char, nmap);
+	for (i = 0; i < nmap && i < sizeof (map); i++)
+		map[i] = intmap[i];
+	g_free(intmap);
+
+	gdk_error_trap_push ();
+
+	/* X refuses to change the mapping while buttons are engaged,
+	 * so if this is the case we'll retry a few times
+	 */
+	for (j = 0;
+	     j < 20 && (rc = XSetDeviceButtonMapping (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), xdev, map, nmap)) == MappingBusy;
+	     ++j) {
+		g_usleep (300);
+	}
+
+	if ((gdk_error_trap_pop () && rc != MappingSuccess) ||
+	    rc != MappingSuccess)
+		g_warning ("Error in setting button mapping for \"%s\"", gsd_wacom_device_get_tool_name (device));
+
+	g_free (map);
+
+	XCloseDevice (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), xdev);
+}
+
+static void
+set_touch (GsdWacomDevice *device,
+	   gboolean	touch)
+{
+	gchar data = touch;
+	PropertyHelper property = {
+		.name = "Wacom Enable Touch",
+		.nitems = 1,
+		.format = 8,
+		.type   = XA_INTEGER,
+		.data.c = &data,
+	};
+
+	wacom_set_property (device, &property);
+}
+
+static void
+set_tpcbutton (GsdWacomDevice *device,
+	       gboolean	tpcbutton)
+{
+	/* Wacom's TPCButton option which this setting emulates is to enable
+	 * Tablet PC stylus behaviour when on. The property "Hover Click"
+	 * works the other way round, i.e. if Hover Click is enabled this
+	 * is the equivalent of TPC behaviour disabled. */
+	gchar data = tpcbutton ? 0 : 1;
+	PropertyHelper property = {
+		.name = "Wacom Hover Click",
+		.nitems = 1,
+		.format = 8,
+		.type   = XA_INTEGER,
+		.data.c = &data,
+	};
+
+	wacom_set_property (device, &property);
+}
+
+static void
+set_pressurethreshold (GsdWacomDevice *device,
+		       gint	    threshold)
+{
+	PropertyHelper property = {
+		.name = "Wacom Pressure Threshold",
+		.nitems = 1,
+		.format = 32,
+		.type   = XA_INTEGER,
+		.data.i = &threshold,
+	};
+
+	wacom_set_property (device, &property);
+}
+
+static void
+apply_stylus_settings (GsdWacomDevice *device)
+{
+	GConfValue *value;
+	GsdWacomStylus *stylus;
+	int threshold;
+
+	g_object_get (device, "last-stylus", &stylus, NULL);
+	g_debug ("Applying setting for stylus '%s' on device '%s'",
+		 gsd_wacom_stylus_get_name (stylus),
+		 gsd_wacom_device_get_name (device));
+
+	value = gsd_gconf_get (gsd_wacom_stylus_get_settings_path (stylus),
+			       gsd_wacom_stylus_get_schemas_path (stylus),
+			       KEY_PRESSURECURVE);
+	set_pressurecurve (device, value);
+	gconf_value_free (value);
+
+	value = gsd_gconf_get (gsd_wacom_stylus_get_settings_path (stylus),
+			       gsd_wacom_stylus_get_schemas_path (stylus),
+			       KEY_BUTTON_MAPPING);
+	set_device_buttonmap (device, value);
+	gconf_value_free (value);
+
+	value = gsd_gconf_get (gsd_wacom_stylus_get_settings_path (stylus),
+			       gsd_wacom_stylus_get_schemas_path (stylus),
+			       KEY_PRESSURETHRESHOLD);
+	threshold = gconf_value_get_int (value);
+	if (threshold == -1)
+		threshold = DEFAULT_PRESSURE_THRESHOLD;
+	set_pressurethreshold (device, threshold);
+	gconf_value_free (value);
+}
+
+static void
+set_led (GsdWacomDevice *device,
+	 int             group_id,
+	 int             index)
+{
+	/* FIXME implement */
+	g_message ("Switched group ID %d to index %d", group_id, index);
+}
+
+struct DefaultButtons {
+	const char *button;
+	int	 num;
+};
+
+struct DefaultButtons def_touchrings_buttons[] = {
+	/* Touchrings */
+	{ "AbsWheelUp", 90 },
+	{ "AbsWheelDown", 91 },
+	{ "RelWheelUp", 90 },
+	{ "RelWheelDown", 91 },
+	{ "AbsWheel2Up", 92 },
+	{ "AbsWheel2Down", 93 },
+	{ NULL, 0 }
+};
+
+struct DefaultButtons def_touchstrip_buttons[] = {
+	/* Touchstrips */
+	{ "StripLeftUp", 94 },
+	{ "StripLeftDown", 95 },
+	{ "StripRightUp", 96 },
+	{ "StripRightDown", 97 },
+	{ NULL, 0 }
+};
+
+static void
+reset_touch_buttons (XDevice               *xdev,
+		     struct DefaultButtons *buttons,
+		     const char            *device_property)
+{
+	Atom actions[6];
+	Atom action_prop;
+	guint i;
+
+	/* Create a device property with the action for button i */
+	for (i = 0; buttons[i].button != NULL; i++)
+	{
+		char *propname;
+		int action[2]; /* press + release */
+		Atom prop;
+		int mapped_button = buttons[i].num;
+
+		action[0] = AC_BUTTON | AC_KEYBTNPRESS | mapped_button;
+		action[1] = AC_BUTTON | mapped_button;
+
+		propname = g_strdup_printf ("Button %s action", buttons[i].button);
+		prop = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), propname, False);
+		g_free (propname);
+		XChangeDeviceProperty (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), xdev,
+				       prop, XA_INTEGER, 32, PropModeReplace,
+				       (const guchar *) &action, 2);
+
+		/* prop now contains press + release for the mapped button */
+		actions[i] = prop;
+	}
+
+	/* Now set the actual action property to contain references to the various
+	 * actions */
+	action_prop = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), device_property, True);
+	XChangeDeviceProperty (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), xdev,
+			       action_prop, XA_ATOM, 32, PropModeReplace,
+			       (const guchar *) actions, i);
+}
+
+static void
+reset_pad_buttons (GsdWacomDevice *device)
+{
+	XDevice *xdev;
+	int nmap;
+	unsigned char *map;
+	int i, j, rc;
+
+	/* Normal buttons */
+	xdev = open_device (device);
+
+	gdk_error_trap_push ();
+
+	nmap = 256;
+	map = g_new0 (unsigned char, nmap);
+	for (i = 0; i < nmap && i < sizeof (map); i++)
+		map[i] = i + 1;
+
+	/* X refuses to change the mapping while buttons are engaged,
+	 * so if this is the case we'll retry a few times */
+	for (j = 0;
+	     j < 20 && (rc = XSetDeviceButtonMapping (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), xdev, map, nmap)) == MappingBusy;
+	     ++j) {
+		g_usleep (300);
+	}
+
+	if ((gdk_error_trap_pop () && rc != MappingSuccess) ||
+	    rc != MappingSuccess)
+		g_warning ("Error in resetting button mapping for \"%s\" (rc=%d)", gsd_wacom_device_get_tool_name (device), rc);
+
+	g_free (map);
+
+	gdk_error_trap_push ();
+	reset_touch_buttons (xdev, def_touchrings_buttons, "Wacom Wheel Buttons");
+	reset_touch_buttons (xdev, def_touchstrip_buttons, "Wacom Strip Buttons");
+	gdk_error_trap_pop ();
+
+	XCloseDevice (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), xdev);
+
+	/* Reset all the LEDs */
+	/* FIXME, get the number of modes somewhere else */
+	for (i = 0; i < 4; i++)
+		set_led (device, i, 0);
+}
+
+static void
+set_wacom_settings (GsdWacomManager *manager,
+		    GsdWacomDevice  *device)
+{
+	GsdWacomDeviceType type;
+	GConfValue *value;
+
+	g_debug ("Applying settings for device '%s' (type: %s)",
+		 gsd_wacom_device_get_tool_name (device),
+		 gsd_wacom_device_type_to_string (gsd_wacom_device_get_device_type (device)));
+
+	value = gsd_gconf_get (gsd_wacom_device_get_settings_path (device),
+			       gsd_wacom_device_get_schemas_path (device),
+			       KEY_ROTATION);
+	set_rotation (device, gsd_wacom_get_rotation_type_from_name (gconf_value_get_string (value)));
+	gconf_value_free (value);
+
+	value = gsd_gconf_get (gsd_wacom_device_get_settings_path (device),
+			       gsd_wacom_device_get_schemas_path (device),
+			       KEY_TOUCH);
+	set_touch (device, gconf_value_get_bool (value));
+	gconf_value_free (value);
+
+	type = gsd_wacom_device_get_device_type (device);
+
+	if (type == WACOM_TYPE_TOUCH) {
+		set_absolute (device, FALSE);
+		return;
+	}
+
+	if (type == WACOM_TYPE_CURSOR) {
+		int values[] = {-1, -1, -1, -1};
+
+		set_absolute (device, FALSE);
+
+		value = gconf_value_new (GCONF_VALUE_LIST);
+		gconf_value_set_list_type (value, GCONF_VALUE_INT);
+		gsd_gconf_value_set_int_array (value, values, G_N_ELEMENTS (values));
+
+		set_area (device, value);
+		gconf_value_free (value);
+
+		return;
+	}
+
+	if (type == WACOM_TYPE_PAD) {
+		int id;
+
+		id = get_device_id (device);
+		reset_pad_buttons (device);
+		grab_button (id, TRUE, manager->priv->screens);
+		return;
+	}
+
+	if (type == WACOM_TYPE_STYLUS) {
+		value = gsd_gconf_get (gsd_wacom_device_get_settings_path (device),
+				       gsd_wacom_device_get_schemas_path (device),
+				       KEY_TPCBUTTON);
+		set_tpcbutton (device, gconf_value_get_bool (value));
+		gconf_value_free (value);
+	}
+
+	value = gsd_gconf_get (gsd_wacom_device_get_settings_path (device),
+			       gsd_wacom_device_get_schemas_path (device),
+			       KEY_IS_ABSOLUTE);
+	set_absolute (device, gconf_value_get_bool (value));
+	gconf_value_free (value);
+
+	value = gsd_gconf_get (gsd_wacom_device_get_settings_path (device),
+			       gsd_wacom_device_get_schemas_path (device),
+			       KEY_AREA);
+	set_area (device, value);
+	gconf_value_free (value);
+
+	value = gsd_gconf_get (gsd_wacom_device_get_settings_path (device),
+			       gsd_wacom_device_get_schemas_path (device),
+			       KEY_DISPLAY);
+	set_display (device, value);
+	gconf_value_free (value);
+
+	/* only pen and eraser have pressure threshold and curve settings */
+	if (type == WACOM_TYPE_STYLUS ||
+	    type == WACOM_TYPE_ERASER) {
+		apply_stylus_settings (device);
+	}
+}
+
+static void
+wacom_settings_changed (GConfValue     *value,
+			gchar          *key,
+			GsdWacomDevice *device)
+{
+	GsdWacomDeviceType type;
+
+	type = gsd_wacom_device_get_device_type (device);
+
+	if (g_str_equal (key, KEY_ROTATION)) {
+		set_rotation (device, gsd_wacom_get_rotation_type_from_name (gconf_value_get_string (value)));
+	} else if (g_str_equal (key, KEY_TOUCH)) {
+		set_touch (device, gconf_value_get_bool (value));
+	} else if (g_str_equal (key, KEY_TPCBUTTON)) {
+		set_tpcbutton (device, gconf_value_get_bool (value));
+	} else if (g_str_equal (key, KEY_IS_ABSOLUTE)) {
+		if (type != WACOM_TYPE_CURSOR &&
+		    type != WACOM_TYPE_PAD &&
+		    type != WACOM_TYPE_TOUCH)
+			set_absolute (device, gconf_value_get_bool (value));
+	} else if (g_str_equal (key, KEY_AREA)) {
+		if (type != WACOM_TYPE_CURSOR &&
+		    type != WACOM_TYPE_PAD)
+			set_area (device, value);
+	} else if (g_str_equal (key, KEY_DISPLAY)) {
+		if (type != WACOM_TYPE_CURSOR &&
+		    type != WACOM_TYPE_PAD)
+			set_display (device, value);
+	} else {
+		g_warning ("Unhandled tablet-wide setting '%s' changed", key);
+	}
+}
+
+static void
+stylus_settings_changed (GConfValue     *value,
+			 gchar          *key,
+			 GsdWacomStylus *stylus)
+{
+	GsdWacomDevice *device;
+	GsdWacomStylus *last_stylus;
+
+	device = gsd_wacom_stylus_get_device (stylus);
+
+	g_object_get (device, "last-stylus", &last_stylus, NULL);
+	if (last_stylus != stylus) {
+		g_debug ("Not applying changed settings because '%s' is the current stylus, not '%s'",
+			 last_stylus ? gsd_wacom_stylus_get_name (last_stylus) : "NONE",
+			 gsd_wacom_stylus_get_name (stylus));
+		return;
+	}
+
+	if (g_str_equal (key, KEY_PRESSURECURVE)) {
+		set_pressurecurve (device, value);
+	} else if (g_str_equal (key, KEY_PRESSURETHRESHOLD)) {
+		int threshold;
+
+		threshold = gconf_value_get_int (value);
+		if (threshold == -1)
+			threshold = DEFAULT_PRESSURE_THRESHOLD;
+		set_pressurethreshold (device, threshold);
+	} else if (g_str_equal (key, KEY_BUTTON_MAPPING)) {
+		set_device_buttonmap (device, value);
+	} else {
+		g_warning ("Unhandled stylus setting '%s' changed", key);
+	}
+}
+
+static void
+last_stylus_changed (GsdWacomDevice  *device)
+{
+	g_debug ("Stylus for device '%s' changed, applying settings",
+		 gsd_wacom_device_get_name (device));
+	apply_stylus_settings (device);
+}
+
+static void
+device_added_cb (GsdDeviceManager *device_manager,
+		 XDeviceInfo      *device_info,
+		 GsdWacomManager  *manager)
+{
+	GsdWacomDevice *device;
+	GConfClient    *client;
+	const char     *settings_path;
+
+	device = gsd_wacom_device_new (device_info);
+	if (gsd_wacom_device_get_device_type (device) == WACOM_TYPE_INVALID) {
+		g_debug ("Device '%s' is invalid", device_info->name);
+		g_object_unref (device);
+		return;
+	}
+	g_debug ("Adding device '%s' (type: '%s') to known devices list",
+		 gsd_wacom_device_get_tool_name (device),
+		 gsd_wacom_device_type_to_string (gsd_wacom_device_get_device_type (device)));
+	g_hash_table_insert (manager->priv->devices, (gpointer) device_info, device);
+
+	if (gsd_wacom_device_get_device_type (device) == WACOM_TYPE_STYLUS ||
+	    gsd_wacom_device_get_device_type (device) == WACOM_TYPE_ERASER) {
+		g_signal_connect (G_OBJECT (device), "notify::last-stylus",
+				  G_CALLBACK (last_stylus_changed), manager);
+	}
+	set_wacom_settings (manager, device);
+
+	/* GConf backport */
+	settings_path = gsd_wacom_device_get_settings_path (device);
+	if (settings_path) {
+		client = gconf_client_get_default ();
+		gconf_client_add_dir (client, settings_path, GCONF_CLIENT_PRELOAD_NONE, NULL);
+		g_object_unref (client);
+	}
+}
+
+static void
+device_removed_cb (GsdDeviceManager *device_manager,
+		   XDeviceInfo      *device_info,
+		   GsdWacomManager  *manager)
+{
+	GsdWacomDevice *device;
+	GConfClient    *client;
+	const char     *settings_path;
+
+	g_debug ("Removing device '%s' from known devices list",
+		 device_info->name);
+	device = g_hash_table_lookup (manager->priv->devices, device_info);
+	if (device) {
+		settings_path = gsd_wacom_device_get_settings_path (device);
+		if (settings_path) {
+			client = gconf_client_get_default ();
+			gconf_client_remove_dir (client, settings_path, NULL);
+			g_object_unref (client);
+		}
+	}
+	g_hash_table_remove (manager->priv->devices, device_info);
+}
+
+static GsdWacomDevice *
+device_id_to_device (GsdWacomManager *manager,
+		     int              deviceid)
+{
+	GList *devices, *l;
+	GsdWacomDevice *ret;
+
+	ret = NULL;
+	devices = g_hash_table_get_keys (manager->priv->devices);
+
+	for (l = devices; l != NULL; l = l->next) {
+		XDeviceInfo *device_info = l->data;
+		int id;
+
+		id = device_info->id;
+		if (id == deviceid) {
+			ret = g_hash_table_lookup (manager->priv->devices, device_info);
+			break;
+		}
+	}
+
+	g_list_free (devices);
+	return ret;
+}
+
+struct {
+	guint mask;
+	KeySym keysym;
+} mods_keysyms[] = {
+	{ GDK_MOD1_MASK, XK_Alt_L },
+	{ GDK_SHIFT_MASK, XK_Shift_L },
+	{ GDK_CONTROL_MASK, XK_Control_L },
+};
+
+static void
+send_modifiers (Display *display,
+		guint mask,
+		gboolean is_press)
+{
+	guint i;
+
+	if (mask == 0)
+		return;
+
+	for (i = 0; i < G_N_ELEMENTS(mods_keysyms); i++) {
+		if (mask & mods_keysyms[i].mask) {
+			guint keycode;
+
+			keycode = XKeysymToKeycode (display, mods_keysyms[i].keysym);
+			XTestFakeKeyEvent (display, keycode,
+					   is_press ? True : False, 0);
+		}
+	}
+}
+
+static char *
+get_elevator_shortcut_string (GsdWacomTabletButton *wbutton,
+			      GtkDirectionType      dir)
+{
+	char **strv, *str;
+	GConfValue  *value;
+
+	value = gsd_gconf_get (wbutton->settings_path, wbutton->schemas_path, KEY_CUSTOM_ELEVATOR_ACTION);
+	strv = gsd_gconf_value_get_strv (value, NULL);
+	gconf_value_free (value);
+	if (strv == NULL)
+		return NULL;
+
+	if (g_strv_length (strv) >= 1 && dir == GTK_DIR_UP)
+		str = g_strdup (strv[0]);
+	else if (g_strv_length (strv) >= 2 && dir == GTK_DIR_DOWN)
+		str = g_strdup (strv[1]);
+	else
+		str = NULL;
+
+	g_strfreev (strv);
+
+	return str;
+}
+
+static void
+generate_key (GsdWacomTabletButton *wbutton,
+	      int                   group,
+	      Display              *display,
+	      GtkDirectionType      dir,
+	      gboolean              is_press)
+{
+	char                 *str;
+	guint                 keyval;
+	guint                *keycodes;
+	guint                 keycode;
+	guint                 mods;
+	GdkKeymapKey         *keys;
+	int                   n_keys;
+	guint                 i;
+	GConfValue           *value;
+
+	if (wbutton->type == WACOM_TABLET_BUTTON_TYPE_ELEVATOR)
+		str = get_elevator_shortcut_string (wbutton, dir);
+	else {
+		value = gsd_gconf_get (wbutton->settings_path, wbutton->schemas_path, KEY_CUSTOM_ACTION);
+		str = g_strdup (gconf_value_get_string (value));
+		gconf_value_free (value);
+	}
+
+	if (str == NULL)
+		return;
+
+	gsd_accelerator_parse_with_keycode (str, &keyval, &keycodes, &mods);
+	if (keycodes == NULL) {
+		g_warning ("Failed to find a keycode for shortcut '%s'", str);
+		g_free (str);
+		return;
+	}
+	g_free (keycodes);
+
+	/* Now look for our own keycode, in the group as us */
+	if (!gdk_keymap_get_entries_for_keyval (gdk_keymap_get_default (), keyval, &keys, &n_keys)) {
+		g_warning ("Failed to find a keycode for keyval '%s' (0x%x)", gdk_keyval_name (keyval), keyval);
+		g_free (str);
+		return;
+	}
+
+	keycode = 0;
+	for (i = 0; i < n_keys; i++) {
+		if (keys[i].group != group)
+			continue;
+		if (keys[i].level > 0)
+			continue;
+		keycode = keys[i].keycode;
+	}
+	/* Couldn't find it in the current group? Look in group 0 */
+	if (keycode == 0) {
+		for (i = 0; i < n_keys; i++) {
+			if (keys[i].level > 0)
+				continue;
+			keycode = keys[i].keycode;
+		}
+	}
+	g_free (keys);
+
+	g_debug ("Emitting '%s' (keyval: %d, keycode: %d mods: 0x%x)",
+		 str, keyval, keycode, mods);
+	g_free (str);
+
+	/* And send out the keys! */
+	if (is_press)
+		send_modifiers (display, mods, TRUE);
+	XTestFakeKeyEvent (display, keycode,
+			   is_press ? True : False, 0);
+	if (is_press == FALSE)
+		send_modifiers (display, mods, FALSE);
+}
+
+static GdkFilterReturn
+filter_button_events (XEvent          *xevent,
+                      GdkEvent        *event,
+                      GsdWacomManager *manager)
+{
+	XIEvent             *xiev;
+	XIDeviceEvent       *xev;
+	XGenericEventCookie *cookie;
+	guint                deviceid;
+	GsdWacomDevice      *device;
+	int                  button;
+	GsdWacomTabletButton *wbutton;
+	GtkDirectionType      dir;
+	const char           *str;
+	GConfValue           *value;
+
+	/* verify we have a key event */
+	if (xevent->type != GenericEvent)
+		return GDK_FILTER_CONTINUE;
+	cookie = &xevent->xcookie;
+	if (cookie->extension != manager->priv->opcode)
+		return GDK_FILTER_CONTINUE;
+
+	xiev = (XIEvent *) xevent->xcookie.data;
+
+	if (xiev == NULL)
+		return GDK_FILTER_CONTINUE;
+
+	if (xiev->evtype != XI_ButtonRelease &&
+	    xiev->evtype != XI_ButtonPress)
+		return GDK_FILTER_CONTINUE;
+
+	xev = (XIDeviceEvent *) xiev;
+
+	deviceid = xev->sourceid;
+	device = device_id_to_device (manager, deviceid);
+	if (gsd_wacom_device_get_device_type (device) != WACOM_TYPE_PAD)
+		return GDK_FILTER_CONTINUE;
+
+	button = xev->detail;
+
+	wbutton = gsd_wacom_device_get_button (device, button, &dir);
+	if (wbutton == NULL) {
+		g_warning ("Could not find matching button for '%d' on '%s'",
+			   button, gsd_wacom_device_get_name (device));
+		return GDK_FILTER_CONTINUE;
+	}
+
+	g_debug ("Received event button %s '%s'%s ('%d') on device '%s' ('%d')",
+		 xiev->evtype == XI_ButtonPress ? "press" : "release",
+		 wbutton->id,
+		 wbutton->type == WACOM_TABLET_BUTTON_TYPE_ELEVATOR ?
+		 (dir == GTK_DIR_UP ? " 'up'" : " 'down'") : "",
+		 button,
+		 gsd_wacom_device_get_name (device),
+		 deviceid);
+
+	if (wbutton->type == WACOM_TABLET_BUTTON_TYPE_HARDCODED) {
+		int new_mode;
+
+		/* We switch modes on key release */
+		if (xiev->evtype == XI_ButtonRelease)
+			return GDK_FILTER_REMOVE;
+
+		new_mode = gsd_wacom_device_set_next_mode (device, wbutton->group_id);
+		set_led (device, wbutton->group_id, new_mode);
+		return GDK_FILTER_REMOVE;
+	}
+
+	/* Nothing to do */
+	value = gsd_gconf_get (wbutton->settings_path, wbutton->schemas_path, KEY_ACTION_TYPE);
+	str = gconf_value_get_string (value);
+	if (gsd_wacom_get_action_type_from_name (str) == GSD_WACOM_ACTION_TYPE_NONE) {
+		gconf_value_free (value);
+		return GDK_FILTER_REMOVE;
+	}
+	gconf_value_free (value);
+
+	/* Send a key combination out */
+	generate_key (wbutton, xev->group.effective, xev->display, dir, xiev->evtype == XI_ButtonPress ? True : False);
+
+	return GDK_FILTER_REMOVE;
+}
+
+static void
+set_devicepresence_handler (GsdWacomManager *manager)
+{
+	GsdDeviceManager *device_manager;
+
+	device_manager = gsd_display_get_device_manager (gdk_display_get_default ());
+	if (device_manager == NULL)
+		return;
+
+	manager->priv->device_added_id = g_signal_connect (G_OBJECT (device_manager), "device-added",
+							   G_CALLBACK (device_added_cb), manager);
+	manager->priv->device_removed_id = g_signal_connect (G_OBJECT (device_manager), "device-removed",
+							     G_CALLBACK (device_removed_cb), manager);
+	manager->priv->device_manager = device_manager;
+}
+
+static GList *
+get_device_list_for_path (GsdWacomManager    *manager,
+			  const char	 *settings_path)
+{
+	GList *devices, *l, *matches;
+
+	g_return_val_if_fail (GSD_IS_WACOM_MANAGER (manager), NULL);
+	g_return_val_if_fail (settings_path != NULL, NULL);
+
+	matches = NULL;
+	devices = g_hash_table_get_values (manager->priv->devices);
+	for (l = devices; l != NULL; l = l->next) {
+		GsdWacomDevice *device = l->data;
+		if (strcmp (gsd_wacom_device_get_settings_path (device), settings_path) == 0)
+			matches = g_list_prepend (matches, device);
+	}
+	g_list_free (devices);
+
+	return matches;
+}
+
+
+static gboolean
+parse_entry (const char *entry, char **device, char **stylus, char **key)
+{
+	char *p;
+
+	*device = *stylus = *key = NULL;
+
+	p = g_strrstr (entry, "/");
+	if (!p) {
+		g_warning ("Cannot determine key from '%s'", entry);
+		return FALSE;
+	}
+	*key = g_strdup (p + 1);
+	*p = '\0';
+
+	p = g_strrstr (entry, "/");
+	if (!p) {
+		*device = g_strdup (entry);
+		return TRUE;
+	}
+	*stylus = g_strdup (p + 1);
+	*p = '\0';
+	*device = g_strdup (entry);
+
+	return TRUE;
+}
+static void
+wacom_callback (GConfClient	 *client,
+		guint		  cnxn_id,
+		GConfEntry	 *entry,
+		GsdWacomManager  *manager)
+{
+	GList *wacom_device_list, *l;
+	const char *prefix;
+	char *key = NULL, *device_name = NULL, *stylus_name = NULL;
+	char *entry_name = NULL, *device_path = NULL, *stylus_path = NULL;
+
+	g_debug ("Notification '%s' changed", entry->key);
+
+	prefix = g_strrstr (entry->key, GCONF_WACOM_DIR_SLASH);
+	if (!prefix) {
+		g_warning ("Ignoring unknown notification for entry '%s'", entry->key);
+		return;
+	}
+
+	prefix += strlen (GCONF_WACOM_DIR_SLASH);
+	entry_name = g_strdup (prefix); /* so we don't touch the GConfEntry data */
+	if (!parse_entry (entry_name, &device_name, &stylus_name, &key)) {
+		g_warning ("Failed to identify device and key for entry '%s'", entry_name);
+		g_free (entry_name);
+		return;
+	}
+
+	device_path = gsd_gconf_build_path (GCONF_WACOM_DIR, device_name);
+	wacom_device_list = get_device_list_for_path (manager, device_path);
+
+	for (l = wacom_device_list; l != NULL; l = l->next) {
+		GsdWacomDevice *wacom_device = l->data;
+
+		if (stylus_name) {
+			GsdWacomStylus *wacom_stylus;
+
+			stylus_path = gsd_gconf_build_path (device_path, stylus_name);
+			wacom_stylus = gsd_wacom_device_get_stylus_for_path (wacom_device, stylus_path);
+			g_free (stylus_path);
+
+			if (wacom_stylus) {
+				/* Apply setting to stylus */
+				stylus_settings_changed (entry->value, key, wacom_stylus);
+			}
+		} else {
+			/* Apply setting to device */
+			g_debug ("Applying setting '%s' to device '%s'", entry->key, device_path);
+			wacom_settings_changed (entry->value, key, wacom_device);
+		}
+	}
+
+	g_list_free (wacom_device_list);
+	g_free (device_path);
+	g_free (entry_name);
+	g_free (device_name);
+	g_free (stylus_name);
+	g_free (key);
+}
+
+static void
+gsd_wacom_manager_init (GsdWacomManager *manager)
+{
+	manager->priv = GSD_WACOM_MANAGER_GET_PRIVATE (manager);
+}
+
+static gboolean
+gsd_wacom_manager_idle_cb (GsdWacomManager *manager)
+{
+	GList *devices, *l;
+	GSList *ls;
+	GConfClient *client;
+
+	gnome_settings_profile_start (NULL);
+
+	manager->priv->devices = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_object_unref);
+
+	set_devicepresence_handler (manager);
+
+	devices = gsd_device_manager_list_devices (manager->priv->device_manager, GSD_DEVICE_TYPE_SLAVE);
+	for (l = devices; l ; l = l->next)
+		device_added_cb (manager->priv->device_manager, l->data, manager);
+	g_list_free (devices);
+
+	client = gconf_client_get_default ();
+	manager->priv->notify_wacom =
+		gconf_client_notify_add (client,
+					 GCONF_WACOM_DIR,
+					 (GConfClientNotifyFunc) wacom_callback,
+					 manager, NULL, NULL);
+	g_object_unref (client);
+
+	/* Start filtering the button events */
+	for (ls = manager->priv->screens; ls != NULL; ls = ls->next) {
+		gdk_window_add_filter (gdk_screen_get_root_window (ls->data),
+				       (GdkFilterFunc) filter_button_events,
+				       manager);
+	}
+
+	gnome_settings_profile_end (NULL);
+
+	manager->priv->start_idle_id = 0;
+
+	return FALSE;
+}
+
+static void
+init_screens (GsdWacomManager *manager)
+{
+	GdkDisplay *display;
+	int i;
+
+	display = gdk_display_get_default ();
+	for (i = 0; i < gdk_display_get_n_screens (display); i++) {
+		GdkScreen *screen;
+
+		screen = gdk_display_get_screen (display, i);
+		if (screen == NULL) {
+			continue;
+		}
+		manager->priv->screens = g_slist_append (manager->priv->screens, screen);
+	}
+}
+
+gboolean
+gsd_wacom_manager_start (GsdWacomManager *manager,
+			 GError	 **error)
+{
+	gnome_settings_profile_start (NULL);
+
+	if (supports_xinput2_devices (&manager->priv->opcode) == FALSE) {
+		g_debug ("No Xinput2 support, disabling plugin");
+		return TRUE;
+	}
+
+	init_screens (manager);
+
+	manager->priv->start_idle_id = g_idle_add ((GSourceFunc) gsd_wacom_manager_idle_cb, manager);
+
+	gnome_settings_profile_end (NULL);
+
+	return TRUE;
+}
+
+void
+gsd_wacom_manager_stop (GsdWacomManager *manager)
+{
+	GsdWacomManagerPrivate *p = manager->priv;
+	GSList *ls;
+
+	g_debug ("Stopping wacom manager");
+
+	if (p->device_manager != NULL) {
+		g_signal_handler_disconnect (p->device_manager, p->device_added_id);
+		g_signal_handler_disconnect (p->device_manager, p->device_removed_id);
+		p->device_manager = NULL;
+	}
+
+	for (ls = p->screens; ls != NULL; ls = ls->next) {
+		gdk_window_remove_filter (gdk_screen_get_root_window (ls->data),
+					  (GdkFilterFunc) filter_button_events,
+					  manager);
+	}
+}
+
+static void
+gsd_wacom_manager_finalize (GObject *object)
+{
+	GsdWacomManager *wacom_manager;
+
+	g_return_if_fail (object != NULL);
+	g_return_if_fail (GSD_IS_WACOM_MANAGER (object));
+
+	wacom_manager = GSD_WACOM_MANAGER (object);
+
+	g_return_if_fail (wacom_manager->priv != NULL);
+
+	if (wacom_manager->priv->devices) {
+		g_hash_table_destroy (wacom_manager->priv->devices);
+		wacom_manager->priv->devices = NULL;
+	}
+
+	if (wacom_manager->priv->screens != NULL) {
+		g_slist_free (wacom_manager->priv->screens);
+		wacom_manager->priv->screens = NULL;
+	}
+
+	if (wacom_manager->priv->start_idle_id != 0)
+		g_source_remove (wacom_manager->priv->start_idle_id);
+
+	G_OBJECT_CLASS (gsd_wacom_manager_parent_class)->finalize (object);
+}
+
+GsdWacomManager *
+gsd_wacom_manager_new (void)
+{
+	if (manager_object != NULL) {
+		g_object_ref (manager_object);
+	} else {
+		manager_object = g_object_new (GSD_TYPE_WACOM_MANAGER, NULL);
+		g_object_add_weak_pointer (manager_object,
+					   (gpointer *) &manager_object);
+	}
+
+	return GSD_WACOM_MANAGER (manager_object);
+}
diff -up gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-manager.h.wacom gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-manager.h
--- gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-manager.h.wacom	2012-03-05 16:52:15.283474346 -0500
+++ gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-manager.h	2012-03-05 16:52:15.283474346 -0500
@@ -0,0 +1,58 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 William Jon McCann <mccann@jhu.edu>
+ * Copyright (C) 2010 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GSD_WACOM_MANAGER_H
+#define __GSD_WACOM_MANAGER_H
+
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+#define GSD_TYPE_WACOM_MANAGER	 (gsd_wacom_manager_get_type ())
+#define GSD_WACOM_MANAGER(o)	   (G_TYPE_CHECK_INSTANCE_CAST ((o), GSD_TYPE_WACOM_MANAGER, GsdWacomManager))
+#define GSD_WACOM_MANAGER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GSD_TYPE_WACOM_MANAGER, GsdWacomManagerClass))
+#define GSD_IS_WACOM_MANAGER(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), GSD_TYPE_WACOM_MANAGER))
+#define GSD_IS_WACOM_MANAGER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GSD_TYPE_WACOM_MANAGER))
+#define GSD_WACOM_MANAGER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GSD_TYPE_WACOM_MANAGER, GsdWacomManagerClass))
+
+typedef struct GsdWacomManagerPrivate GsdWacomManagerPrivate;
+
+typedef struct
+{
+	GObject		     parent;
+	GsdWacomManagerPrivate *priv;
+} GsdWacomManager;
+
+typedef struct
+{
+	GObjectClass   parent_class;
+} GsdWacomManagerClass;
+
+GType		   gsd_wacom_manager_get_type	    (void);
+
+GsdWacomManager *       gsd_wacom_manager_new		 (void);
+gboolean		gsd_wacom_manager_start	       (GsdWacomManager *manager,
+							       GError	 **error);
+void			gsd_wacom_manager_stop		(GsdWacomManager *manager);
+
+G_END_DECLS
+
+#endif /* __GSD_WACOM_MANAGER_H */
diff -up gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-plugin.c.wacom gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-plugin.c
--- gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-plugin.c.wacom	2012-03-05 16:52:15.284474939 -0500
+++ gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-plugin.c	2012-03-05 16:52:15.283474346 -0500
@@ -0,0 +1,106 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 William Jon McCann <mccann@jhu.edu>
+ * Copyright (C) 2010 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <glib/gi18n-lib.h>
+#include <gmodule.h>
+
+#include "gnome-settings-plugin.h"
+#include "gsd-wacom-plugin.h"
+#include "gsd-wacom-manager.h"
+
+struct GsdWacomPluginPrivate {
+	GsdWacomManager *manager;
+};
+
+#define GSD_WACOM_PLUGIN_GET_PRIVATE(object) (G_TYPE_INSTANCE_GET_PRIVATE ((object), GSD_TYPE_WACOM_PLUGIN, GsdWacomPluginPrivate))
+
+GNOME_SETTINGS_PLUGIN_REGISTER (GsdWacomPlugin, gsd_wacom_plugin)
+
+static void
+gsd_wacom_plugin_init (GsdWacomPlugin *plugin)
+{
+	plugin->priv = GSD_WACOM_PLUGIN_GET_PRIVATE (plugin);
+
+	g_debug ("GsdWacomPlugin initializing");
+
+	plugin->priv->manager = gsd_wacom_manager_new ();
+}
+
+static void
+gsd_wacom_plugin_finalize (GObject *object)
+{
+	GsdWacomPlugin *plugin;
+
+	g_return_if_fail (object != NULL);
+	g_return_if_fail (GSD_IS_WACOM_PLUGIN (object));
+
+	g_debug ("GsdWacomPlugin finalizing");
+
+	plugin = GSD_WACOM_PLUGIN (object);
+
+	g_return_if_fail (plugin->priv != NULL);
+
+	if (plugin->priv->manager != NULL) {
+		g_object_unref (plugin->priv->manager);
+	}
+
+	G_OBJECT_CLASS (gsd_wacom_plugin_parent_class)->finalize (object);
+}
+
+static void
+impl_activate (GnomeSettingsPlugin *plugin)
+{
+	gboolean res;
+	GError  *error;
+
+	g_debug ("Activating wacom plugin");
+
+	error = NULL;
+	res = gsd_wacom_manager_start (GSD_WACOM_PLUGIN (plugin)->priv->manager, &error);
+	if (! res) {
+		g_warning ("Unable to start wacom manager: %s", error->message);
+		g_error_free (error);
+	}
+}
+
+static void
+impl_deactivate (GnomeSettingsPlugin *plugin)
+{
+	g_debug ("Deactivating wacom plugin");
+	gsd_wacom_manager_stop (GSD_WACOM_PLUGIN (plugin)->priv->manager);
+}
+
+static void
+gsd_wacom_plugin_class_init (GsdWacomPluginClass *klass)
+{
+	GObjectClass	   *object_class = G_OBJECT_CLASS (klass);
+	GnomeSettingsPluginClass *plugin_class = GNOME_SETTINGS_PLUGIN_CLASS (klass);
+
+	object_class->finalize = gsd_wacom_plugin_finalize;
+
+	plugin_class->activate = impl_activate;
+	plugin_class->deactivate = impl_deactivate;
+
+	g_type_class_add_private (klass, sizeof (GsdWacomPluginPrivate));
+}
+
diff -up gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-plugin.h.wacom gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-plugin.h
--- gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-plugin.h.wacom	2012-03-05 16:52:15.284474939 -0500
+++ gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-plugin.h	2012-03-05 16:52:15.284474939 -0500
@@ -0,0 +1,60 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 William Jon McCann <mccann@jhu.edu>
+ * Copyright (C) 2010 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GSD_WACOM_PLUGIN_H__
+#define __GSD_WACOM_PLUGIN_H__
+
+#include <glib.h>
+#include <glib-object.h>
+#include <gmodule.h>
+
+#include "gnome-settings-plugin.h"
+
+G_BEGIN_DECLS
+
+#define GSD_TYPE_WACOM_PLUGIN		(gsd_wacom_plugin_get_type ())
+#define GSD_WACOM_PLUGIN(o)		  (G_TYPE_CHECK_INSTANCE_CAST ((o), GSD_TYPE_WACOM_PLUGIN, GsdWacomPlugin))
+#define GSD_WACOM_PLUGIN_CLASS(k)	    (G_TYPE_CHECK_CLASS_CAST((k), GSD_TYPE_WACOM_PLUGIN, GsdWacomPluginClass))
+#define GSD_IS_WACOM_PLUGIN(o)	       (G_TYPE_CHECK_INSTANCE_TYPE ((o), GSD_TYPE_WACOM_PLUGIN))
+#define GSD_IS_WACOM_PLUGIN_CLASS(k)	 (G_TYPE_CHECK_CLASS_TYPE ((k), GSD_TYPE_WACOM_PLUGIN))
+#define GSD_WACOM_PLUGIN_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), GSD_TYPE_WACOM_PLUGIN, GsdWacomPluginClass))
+
+typedef struct GsdWacomPluginPrivate GsdWacomPluginPrivate;
+
+typedef struct
+{
+	GnomeSettingsPlugin    parent;
+	GsdWacomPluginPrivate *priv;
+} GsdWacomPlugin;
+
+typedef struct
+{
+	GnomeSettingsPluginClass parent_class;
+} GsdWacomPluginClass;
+
+GType	gsd_wacom_plugin_get_type			(void) G_GNUC_CONST;
+
+/* All the plugins must implement this function */
+G_MODULE_EXPORT GType	register_gnome_settings_plugin	(GTypeModule *module);
+
+G_END_DECLS
+
+#endif /* __GSD_WACOM_PLUGIN_H__ */
diff -up gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-rr-helpers.c.wacom gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-rr-helpers.c
--- gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-rr-helpers.c.wacom	2012-03-05 16:52:15.284474939 -0500
+++ gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-rr-helpers.c	2012-03-05 16:52:15.284474939 -0500
@@ -0,0 +1,324 @@
+/*
+ * Copyright (C) 2012 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Author: Olivier Fourdan <ofourdan@redhat.com>
+ */
+
+#include "config.h"
+
+#include <glib.h>
+#include <gdk/gdk.h>
+#include <gdk/gdkx.h>
+#include <glib/gi18n.h>
+
+#include <string.h>
+#include <X11/Xlib.h>
+#include <X11/extensions/Xrandr.h>
+
+#include "gsd-wacom-rr-helpers.h"
+
+static gboolean
+check_for_partial_xrandr (Display *dpy)
+{
+	XRRScreenResources *res;
+	XRROutputInfo *output_info = NULL;
+	gboolean found = FALSE;
+	int i;
+
+	res = XRRGetScreenResources(dpy, DefaultRootWindow(dpy));
+	for (i = 0; i < res->noutput && !found; i++) {
+		output_info = XRRGetOutputInfo(dpy, res, res->outputs[i]);
+
+		if (output_info->crtc && output_info->connection == RR_Connected &&
+		    strcmp(output_info->name, "default") == 0) {
+			XRRFreeOutputInfo(output_info);
+			found = TRUE;
+			break;
+		}
+		XRRFreeOutputInfo(output_info);
+	}
+	XRRFreeScreenResources(res);
+
+	return found;
+}
+
+gboolean
+gsd_rr_check_xrandr (GdkScreen *gdk_screen,
+		     GError **error)
+{
+	Display *dpy = GDK_SCREEN_XDISPLAY (gdk_screen);
+	int event_base;
+	int ignore;
+
+	g_return_val_if_fail (error == NULL || *error == NULL, FALSE);
+
+	if (XRRQueryExtension (dpy, &event_base, &ignore)) {
+		int major_version, minor_version;
+
+		XRRQueryVersion (dpy, &major_version, &minor_version);
+		if (major_version < 2 && minor_version < 2) {
+			g_set_error (error, GNOME_RR_ERROR, GNOME_RR_ERROR_NO_RANDR_EXTENSION,
+				     _("RANDR extension is too old (%i.%i < 1.2)"), major_version, minor_version);
+			return FALSE;
+		}
+	} else {
+		g_set_error (error, GNOME_RR_ERROR, GNOME_RR_ERROR_NO_RANDR_EXTENSION,
+			     _("RANDR extension is not present"));
+		return FALSE;
+	}
+
+	/*
+	 * You would believe we're good for an Xrandr setup now, wouldn't you?
+	 * Not so fast Bud, we need to check for a (partial) non-RandR setup
+	 * as well (some driver...).
+	 */
+	if (check_for_partial_xrandr (dpy)) {
+		g_set_error (error, GNOME_RR_ERROR, GNOME_RR_ERROR_NO_RANDR_EXTENSION,
+			     _("Existing but partial RANDR extension ignored"));
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+GnomeRRScreen *
+gsd_rr_screen_new (GdkScreen *gdk_screen,
+		   GnomeRRScreenChanged callback,
+		   gpointer data,
+		   GError **error)
+{
+	if (gsd_rr_check_xrandr (gdk_screen, error)) {
+		/* Now we should be safe to pass it all to gnome_rr_screen_new() */
+		return gnome_rr_screen_new (gdk_screen, callback, data, error);
+	}
+	return NULL;
+}
+
+
+gboolean
+gsd_rr_output_info_is_active (GnomeOutputInfo *self)
+{
+	g_return_val_if_fail (self != NULL, FALSE);
+
+	return self->on;
+}
+
+void
+gsd_rr_output_info_get_vendor (GnomeOutputInfo *self,
+			       gchar* vendor)
+{
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (vendor != NULL);
+
+	memcpy (vendor, self->vendor, 4);
+}
+
+guint
+gsd_rr_output_info_get_product (GnomeOutputInfo *self)
+{
+	g_return_val_if_fail (self != NULL, 0);
+
+	return self->product;
+}
+
+guint
+gsd_rr_output_info_get_serial (GnomeOutputInfo *self)
+{
+	g_return_val_if_fail (self != NULL, 0);
+
+	return self->serial;
+}
+
+void
+gsd_rr_output_info_get_geometry (GnomeOutputInfo *self,
+				 int *x,
+				 int *y,
+				 int *width,
+				 int *height)
+{
+	g_return_if_fail (self != NULL);
+
+	if (x)
+		*x = self->x;
+	if (y)
+		*y = self->y;
+	if (width)
+		*width = self->width;
+	if (height)
+		*height = self->height;
+}
+
+const char *
+gsd_rr_output_info_get_name (GnomeOutputInfo *self)
+{
+	g_return_val_if_fail (self != NULL, NULL);
+
+	return self->name ? self->name : _("Unknown");
+}
+
+const char *
+gsd_rr_output_info_get_display_name (GnomeOutputInfo *self)
+{
+	g_return_val_if_fail (self != NULL, NULL);
+
+	return self->display_name ? self->display_name : _("Unknown");
+}
+
+GnomeOutputInfo *
+gsd_rr_compat_output_deep_copy (const GnomeOutputInfo *output)
+{
+	GnomeOutputInfo *copy;
+
+	g_return_val_if_fail (output != NULL, NULL);
+
+	copy               = g_new0 (GnomeOutputInfo, 1);
+	copy->on           = output->on;
+	copy->name         = g_strdup (output->name);
+	copy->width        = output->width;
+	copy->height       = output->height;
+	copy->rate         = output->rate;
+	copy->x            = output->x;
+	copy->y            = output->y;
+	copy->rotation     = output->rotation;
+	copy->connected    = output->connected;
+	g_snprintf (copy->vendor, 4, "%s", output->vendor);
+	copy->product      = output->product;
+	copy->serial       = output->serial;
+	copy->aspect       = output->aspect;
+	copy->pref_width   = output->pref_width;
+	copy->pref_height  = output->pref_height;
+	copy->display_name = g_strdup (output->display_name);
+	copy->primary      = output->primary;
+	copy->user_data    = output->user_data;
+
+	return copy;
+}
+
+void
+gsd_rr_compat_output_free (GnomeOutputInfo *output)
+{
+	if (output == NULL)
+		return;
+
+	if (output->display_name)
+		g_free (output->display_name);
+
+	if (output->name)
+		g_free (output->name);
+
+	g_free (output);
+}
+
+/* Create a fake GnomeOutputInfo based on GdkScreen's monitor */
+static GnomeOutputInfo *
+create_compat_output_from_id (GdkScreen *gscreen,
+			      gint monitor_id)
+{
+	GnomeOutputInfo *output = NULL;
+	GdkRectangle monitor;
+
+	g_return_val_if_fail (monitor_id >= 0, NULL);
+	g_return_val_if_fail (GDK_IS_SCREEN (gscreen), NULL);
+
+	if (monitor_id < gdk_screen_get_n_monitors (gscreen)) {
+		output               = g_new0 (GnomeOutputInfo, 1);
+		output->on           = TRUE;
+		output->name         = g_strdup_printf (_("Monitor %d"), monitor_id);
+		gdk_screen_get_monitor_geometry (gscreen, monitor_id, &monitor);
+		output->width        = monitor.width;
+		output->height       = monitor.height;
+		output->rate         = 0;
+		output->x            = monitor.x;
+		output->y            = monitor.y;
+		output->rotation     = GNOME_RR_ROTATION_0;
+		output->connected    = TRUE;
+		g_snprintf (output->vendor, 4, "%.3d", monitor_id);
+		output->product      = 0;
+		output->serial       = 0;
+		output->aspect       = (double) monitor.width / (double) monitor.height;
+		output->pref_width   = monitor.width;
+		output->pref_height  = monitor.height;
+		output->display_name = gdk_screen_get_monitor_plug_name (gscreen, monitor_id);
+		output->primary      = (monitor_id == 0);
+		output->user_data    = NULL;
+	}
+
+	return output;
+}
+
+/* Copy the list of GnomeOutputInfo from GnomeRRConfig */
+static GnomeOutputInfo **
+copy_rr_config_outputs (GnomeRRConfig *configuration)
+{
+	GnomeOutputInfo **outputs = NULL;
+	GnomeOutputInfo **p1, **p2;
+	gsize nitems;
+
+	g_return_val_if_fail (configuration != NULL, NULL);
+
+	for (p2 = configuration->outputs; *p2; ++p2)
+		nitems++;
+	outputs = g_new0 (GnomeOutputInfo*, nitems + 1);
+	for (p1 = outputs, p2 = configuration->outputs; *p2; ++p2)
+		*p1++ = gsd_rr_compat_output_deep_copy (*p2);
+
+	return outputs;
+}
+
+/* Create a list of fake GnomeOutputInfo based on GdkScreen */
+static GnomeOutputInfo **
+create_compat_outputs_from_screen (GdkScreen *gscreen)
+{
+	GnomeOutputInfo **p, **outputs = NULL;
+	gint n_monitors, i;
+
+	g_return_val_if_fail (GDK_IS_SCREEN (gscreen), NULL);
+
+	n_monitors = gdk_screen_get_n_monitors (gscreen);
+
+	outputs = g_new0 (GnomeOutputInfo*, n_monitors + 1);
+	for (i = 0, p = outputs; i < n_monitors; i++)
+		*p++ = create_compat_output_from_id (gscreen, i);
+
+	return outputs;
+}
+
+GnomeOutputInfo **
+gsd_rr_config_compat_outputs_get (GnomeRRConfig *configuration)
+{
+	GnomeOutputInfo **outputs = NULL;
+
+	if (configuration)
+		outputs = copy_rr_config_outputs (configuration);
+	else
+		outputs = create_compat_outputs_from_screen (gdk_screen_get_default ());
+
+	return outputs;
+}
+
+void
+gsd_rr_config_compat_outputs_free (GnomeOutputInfo **outputs)
+{
+	GnomeOutputInfo **p;
+
+	g_return_if_fail (outputs != NULL);
+
+	for (p = outputs; *p != NULL; ++p)
+		gsd_rr_compat_output_free (*p);
+
+	g_free (outputs);
+}
diff -up gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-rr-helpers.h.wacom gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-rr-helpers.h
--- gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-rr-helpers.h.wacom	2012-03-05 16:52:15.285476602 -0500
+++ gnome-settings-daemon-2.28.2/plugins/wacom/gsd-wacom-rr-helpers.h	2012-03-05 16:52:15.285476602 -0500
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2012 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Author: Olivier Fourdan <ofourdan@redhat.com>
+ */
+
+#include "config.h"
+
+#include <glib.h>
+#define GNOME_DESKTOP_USE_UNSTABLE_API
+#include <libgnomeui/gnome-rr.h>
+#include <libgnomeui/gnome-rr-config.h>
+
+#ifndef __GSD_RR_HELPERS_H__
+#define __GSD_RR_HELPERS_H__
+
+G_BEGIN_DECLS
+
+/* Simple defs to keep forward compat with GNOME 3 API*/
+
+gboolean		gsd_rr_check_xrandr			(GdkScreen *,
+								 GError **);
+GnomeRRScreen *		gsd_rr_screen_new 			(GdkScreen *,
+								 GnomeRRScreenChanged,
+								 gpointer,
+								 GError **);
+gboolean		gsd_rr_output_info_is_active		(GnomeOutputInfo *);
+void			gsd_rr_output_info_get_vendor		(GnomeOutputInfo *,
+								 gchar *);
+guint			gsd_rr_output_info_get_product		(GnomeOutputInfo *);
+guint			gsd_rr_output_info_get_serial		(GnomeOutputInfo *);
+void			gsd_rr_output_info_get_geometry		(GnomeOutputInfo *,
+								 int *x,
+								 int *y,
+								 int *width,
+								 int *height);
+const char *		gsd_rr_output_info_get_name 		(GnomeOutputInfo *);
+const char *		gsd_rr_output_info_get_display_name	(GnomeOutputInfo *);
+GnomeOutputInfo *	gsd_rr_compat_output_deep_copy		(const GnomeOutputInfo *);
+void			gsd_rr_compat_output_free		(GnomeOutputInfo *);
+GnomeOutputInfo **	gsd_rr_config_compat_outputs_get	(GnomeRRConfig *);
+void			gsd_rr_config_compat_outputs_free	(GnomeOutputInfo **);
+
+G_END_DECLS
+
+#endif /* __GSD_RR_HELPERS_H__ */
diff -up gnome-settings-daemon-2.28.2/plugins/wacom/list-wacom.c.wacom gnome-settings-daemon-2.28.2/plugins/wacom/list-wacom.c
--- gnome-settings-daemon-2.28.2/plugins/wacom/list-wacom.c.wacom	2012-03-05 16:52:15.285476602 -0500
+++ gnome-settings-daemon-2.28.2/plugins/wacom/list-wacom.c	2012-03-05 16:52:15.285476602 -0500
@@ -0,0 +1,286 @@
+/*
+ * Copyright (C) 2011 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Author: Bastien Nocera <hadess@hadess.net>
+ *
+ */
+
+#include "config.h"
+
+#include <gtk/gtk.h>
+
+#include "gsd-wacom-device.h"
+#include "gsd-wacom-devmanager-helpers.h"
+
+static gboolean fake_devices = FALSE;
+static gboolean monitor_styli = FALSE;
+static gboolean option_debug = FALSE;
+
+static const char *
+stylus_type_to_string (GsdWacomStylusType type)
+{
+	switch (type) {
+	case WACOM_STYLUS_TYPE_UNKNOWN:
+		return "Unknown";
+	case WACOM_STYLUS_TYPE_GENERAL:
+		return "General";
+	case WACOM_STYLUS_TYPE_INKING:
+		return "Inking";
+	case WACOM_STYLUS_TYPE_AIRBRUSH:
+		return "Airbrush";
+	case WACOM_STYLUS_TYPE_CLASSIC:
+		return "Classic";
+	case WACOM_STYLUS_TYPE_MARKER:
+		return "Marker";
+	case WACOM_STYLUS_TYPE_STROKE:
+		return "Stroke";
+	case WACOM_STYLUS_TYPE_PUCK:
+		return "Puck";
+	default:
+		g_assert_not_reached ();
+	}
+	return NULL;
+}
+
+static const char *
+button_type_to_string (GsdWacomTabletButtonType type)
+{
+	switch (type) {
+	case WACOM_TABLET_BUTTON_TYPE_NORMAL:
+		return "normal";
+	case WACOM_TABLET_BUTTON_TYPE_ELEVATOR:
+		return "elevator";
+	case WACOM_TABLET_BUTTON_TYPE_HARDCODED:
+		return "hard-coded";
+	default:
+		g_assert_not_reached ();
+	}
+}
+
+#define BOOL_AS_STR(x) (x ? "yes" : "no")
+
+static void
+print_stylus (GsdWacomStylus *stylus,
+	      gboolean	is_current)
+{
+	GsdWacomDevice *device;
+	const char *loc;
+
+	device = gsd_wacom_stylus_get_device (stylus);
+
+	g_print ("\t%sStylus: '%s' (Type: %s, ID: 0x%x)\n",
+		 is_current ? "*** " : "",
+		 gsd_wacom_stylus_get_name (stylus),
+		 stylus_type_to_string (gsd_wacom_stylus_get_stylus_type (stylus)),
+		 gsd_wacom_stylus_get_id (stylus));
+
+	loc = gsd_wacom_stylus_get_settings_path (stylus);
+	g_print ("\t\tSettings: %s\n", loc);
+
+	g_print ("\t\tIcon name: %s\n", gsd_wacom_stylus_get_icon_name (stylus));
+
+	if (gsd_wacom_device_get_device_type (device) == WACOM_TYPE_STYLUS) {
+		int num_buttons;
+		char *buttons;
+
+		g_print ("\t\tHas Eraser: %s\n", BOOL_AS_STR(gsd_wacom_stylus_get_has_eraser (stylus)));
+
+		num_buttons = gsd_wacom_stylus_get_num_buttons (stylus);
+		if (num_buttons < 0)
+			num_buttons = 2;
+		if (num_buttons > 0)
+			buttons = g_strdup_printf ("%d buttons", num_buttons);
+		else
+			buttons = g_strdup ("no button");
+		g_print ("\t\tButtons: %s\n", buttons);
+		g_free (buttons);
+	}
+}
+
+static void
+print_buttons (GsdWacomDevice *device)
+{
+	GList *buttons, *l;
+
+	buttons = gsd_wacom_device_get_buttons (device);
+	if (buttons == NULL)
+		return;
+
+	for (l = buttons; l != NULL; l = l->next) {
+		GsdWacomTabletButton *button = l->data;
+
+		g_print ("\tButton: %s (%s)\n", button->name, button->id);
+		g_print ("\t\tType: %s\n", button_type_to_string (button->type));
+		if (button->group_id > 0) {
+			g_print ("\t\tGroup: %d", button->group_id);
+			if (button->idx >= 0)
+				g_print (" Index: %d\n", button->idx);
+			else
+				g_print ("\n");
+		}
+		if (button->settings_path) {
+			char *loc;
+			loc = button->settings_path;
+			g_print ("\t\tSettings: %s\n", loc);
+		}
+	}
+	g_list_free (buttons);
+}
+
+static void
+last_stylus_changed (GsdWacomDevice  *device,
+		     GParamSpec      *pspec,
+		     gpointer	 user_data)
+{
+	GsdWacomStylus *stylus;
+
+	g_object_get (device, "last-stylus", &stylus, NULL);
+
+	g_print ("Stylus changed for device '%s'\n",
+		 gsd_wacom_device_get_tool_name (device));
+
+	print_stylus (stylus, TRUE);
+}
+
+static void
+list_devices (GList *devices)
+{
+	GList *l;
+
+	for (l = devices; l ; l = l->next) {
+		GsdWacomDevice *device;
+		GsdWacomDeviceType type;
+		const char *loc;
+
+		device = l->data;
+
+		g_signal_connect (G_OBJECT (device), "notify::last-stylus",
+				  G_CALLBACK (last_stylus_changed), NULL);
+
+		g_print ("Device '%s' (type: %s)\n",
+			 gsd_wacom_device_get_name (device),
+			 gsd_wacom_device_type_to_string (gsd_wacom_device_get_device_type (device)));
+		g_print ("\tReversible: %s\n", BOOL_AS_STR (gsd_wacom_device_reversible (device)));
+		g_print ("\tScreen Tablet: %s\n", BOOL_AS_STR (gsd_wacom_device_is_screen_tablet (device)));
+
+		loc = gsd_wacom_device_get_settings_path (device);
+		g_print ("\tGeneric settings: %s\n", loc);
+
+		type = gsd_wacom_device_get_device_type (device);
+		if (type == WACOM_TYPE_STYLUS ||
+		    type == WACOM_TYPE_ERASER) {
+			GList *styli, *j;
+			GsdWacomStylus *current_stylus;
+
+			g_object_get (device, "last-stylus", &current_stylus, NULL);
+
+			styli = gsd_wacom_device_list_styli (device);
+			for (j = styli; j; j = j->next) {
+				GsdWacomStylus *stylus;
+
+				stylus = j->data;
+				print_stylus (stylus, current_stylus == stylus);
+			}
+			g_list_free (styli);
+		}
+
+		print_buttons (device);
+
+		if (monitor_styli == FALSE)
+			g_object_unref (device);
+	}
+	g_list_free (devices);
+}
+
+static void
+list_actual_devices (void)
+{
+	GsdDeviceManager *mgr;
+	GList *list, *l, *devices;
+
+	mgr = gsd_display_get_device_manager (gdk_display_get_default ());
+
+	list = gsd_device_manager_list_devices (mgr, GSD_DEVICE_TYPE_SLAVE);
+	devices = NULL;
+	for (l = list; l ; l = l->next) {
+		GsdWacomDevice *device;
+
+		device = gsd_wacom_device_new (l->data);
+		if (gsd_wacom_device_get_device_type (device) == WACOM_TYPE_INVALID) {
+			g_object_unref (device);
+			continue;
+		}
+
+		devices = g_list_prepend (devices, device);
+	}
+	g_list_free (list);
+
+	list_devices (devices);
+}
+
+static void
+list_fake_devices (void)
+{
+	GList *devices;
+
+	devices = gsd_wacom_device_create_fake_cintiq ();
+	list_devices (devices);
+
+	devices = gsd_wacom_device_create_fake_bt ();
+	list_devices (devices);
+
+	devices = gsd_wacom_device_create_fake_x201 ();
+	list_devices (devices);
+
+	devices = gsd_wacom_device_create_fake_intuos4 ();
+	list_devices (devices);
+}
+
+int main (int argc, char **argv)
+{
+	GError *error = NULL;
+	GOptionContext *context;
+	const GOptionEntry entries[] = {
+		{ "fake", 'f', 0, G_OPTION_ARG_NONE, &fake_devices, "Output fake devices", NULL },
+		{ "monitor", 'm', 0, G_OPTION_ARG_NONE, &monitor_styli, "Monitor changing styli", NULL },
+		{ "debug", 'd', 0, G_OPTION_ARG_NONE, &option_debug, "Debug output", NULL },
+		{ NULL }
+	};
+
+	gtk_init (&argc, &argv);
+
+	context = g_option_context_new ("- test parser functions");
+	g_option_context_add_main_entries (context, entries, GETTEXT_PACKAGE);
+
+	if (g_option_context_parse (context, &argc, &argv, &error) == FALSE) {
+		g_print ("Option parsing failed: %s\n", error->message);
+		return 1;
+	}
+
+	if (option_debug)
+		g_setenv ("G_MESSAGES_DEBUG", "all", TRUE);
+
+	if (fake_devices == FALSE)
+		list_actual_devices ();
+	else
+		list_fake_devices ();
+
+	if (monitor_styli)
+		gtk_main ();
+
+	return 0;
+}
diff -up gnome-settings-daemon-2.28.2/plugins/wacom/Makefile.am.wacom gnome-settings-daemon-2.28.2/plugins/wacom/Makefile.am
--- gnome-settings-daemon-2.28.2/plugins/wacom/Makefile.am.wacom	2012-03-05 16:52:15.286516073 -0500
+++ gnome-settings-daemon-2.28.2/plugins/wacom/Makefile.am	2012-03-05 16:52:15.286516073 -0500
@@ -0,0 +1,145 @@
+noinst_LTLIBRARIES = libgsdwacomhelpers.la
+
+libgsdwacomhelpers_la_SOURCES = \
+	gsd-wacom-devmanager-helpers.c					\
+	gsd-wacom-devmanager-helpers.h					\
+	gsd-wacom-gconf-helpers.c					\
+	gsd-wacom-gconf-helpers.h					\
+	gsd-wacom-gdk-helpers.c						\
+	gsd-wacom-gdk-helpers.h						\
+	gsd-wacom-rr-helpers.c						\
+	gsd-wacom-rr-helpers.h
+
+libgsdwacomhelpers_la_CPPFLAGS = 					\
+	$(AM_CPPFLAGS)
+
+libgsdwacomhelpers_la_CFLAGS = 						\
+	$(SETTINGS_PLUGIN_CFLAGS)					\
+	$(AM_CFLAGS)
+
+libgsdwacomhelpers_la_LDFLAGS = 					\
+	$(GSD_PLUGIN_LDFLAGS)
+
+libgsdwacomhelpers_la_LIBADD  = 					\
+	$(SETTINGS_PLUGIN_LIBS)
+
+
+plugin_LTLIBRARIES = libgsdwacom.la
+
+libgsdwacom_la_SOURCES = 						\
+	gsd-wacom-device.c						\
+	gsd-wacom-device.h						\
+	gsd-wacom-manager.c						\
+	gsd-wacom-manager.h						\
+	gsd-wacom-plugin.c						\
+	gsd-wacom-plugin.h
+
+libgsdwacom_la_CPPFLAGS = \
+	-I$(top_srcdir)/gnome-settings-daemon				\
+	-I$(top_srcdir)/plugins/common/					\
+	-DGNOME_SETTINGS_LOCALEDIR=\""$(datadir)/locale"\" 		\
+	$(AM_CPPFLAGS)
+
+libgsdwacom_la_CFLAGS = \
+	$(SETTINGS_PLUGIN_CFLAGS)					\
+	$(LIBWACOM_CFLAGS)						\
+	$(AM_CFLAGS)
+
+libgsdwacom_la_LDFLAGS = 						\
+	$(GSD_PLUGIN_LDFLAGS)
+
+libgsdwacom_la_LIBADD  = 						\
+	$(top_builddir)/gnome-settings-daemon/libgsd-profile.la		\
+	$(top_builddir)/plugins/common/libcommon.la			\
+	$(builddir)/libgsdwacomhelpers.la				\
+	$(SETTINGS_PLUGIN_LIBS)						\
+	$(LIBWACOM_LIBS)						\
+	$(NULL)
+
+noinst_PROGRAMS = test-wacom list-wacom test-devman
+
+test_wacom_SOURCES =							\
+	test-wacom.c							\
+	gsd-wacom-manager.c						\
+	gsd-wacom-manager.h						\
+	gsd-wacom-device.c						\
+	gsd-wacom-device.h
+
+test_wacom_CPPFLAGS = \
+	-I$(top_srcdir)/data/						\
+	-I$(top_srcdir)/plugins/common/					\
+	-I$(top_srcdir)/gnome-settings-daemon				\
+	-DBINDIR=\"$(bindir)\"						\
+	-DPIXMAPDIR=\""$(pkgdatadir)"\"					\
+	-DGTKBUILDERDIR=\""$(pkgdatadir)"\"				\
+	-DGNOME_SETTINGS_LOCALEDIR=\""$(datadir)/locale"\"		\
+	$(AM_CPPFLAGS)
+
+test_wacom_CFLAGS =							\
+	$(SETTINGS_PLUGIN_CFLAGS)					\
+	$(LIBWACOM_CFLAGS)						\
+	$(AM_CFLAGS)
+
+test_wacom_LDADD = \
+	$(top_builddir)/gnome-settings-daemon/libgsd-profile.la		\
+	$(top_builddir)/plugins/common/libcommon.la			\
+	$(builddir)/libgsdwacomhelpers.la				\
+	$(SETTINGS_PLUGIN_LIBS)						\
+	$(LIBWACOM_LIBS)						\
+	$(NULL)
+
+list_wacom_SOURCES =							\
+	list-wacom.c							\
+	gsd-wacom-device.c						\
+	gsd-wacom-device.h
+
+list_wacom_CPPFLAGS = \
+	-I$(top_srcdir)/data/						\
+	-I$(top_srcdir)/gnome-settings-daemon				\
+	-I$(top_srcdir)/plugins/common					\
+	-I$(top_srcdir)/plugins/common/					\
+	-DBINDIR=\"$(bindir)\"						\
+	-DPIXMAPDIR=\""$(pkgdatadir)"\"					\
+	-DGTKBUILDERDIR=\""$(pkgdatadir)"\"				\
+	-DGNOME_SETTINGS_LOCALEDIR=\""$(datadir)/locale"\"		\
+	$(AM_CPPFLAGS)
+
+list_wacom_CFLAGS =							\
+	$(SETTINGS_PLUGIN_CFLAGS)					\
+	$(LIBWACOM_CFLAGS)						\
+	$(AM_CFLAGS)
+
+list_wacom_LDADD = \
+	$(top_builddir)/gnome-settings-daemon/libgsd-profile.la		\
+	$(top_builddir)/plugins/common/libcommon.la			\
+	$(builddir)/libgsdwacomhelpers.la				\
+	$(SETTINGS_DAEMON_LIBS)						\
+	$(SETTINGS_PLUGIN_LIBS)						\
+	$(LIBWACOM_LIBS)
+
+test_devman_SOURCES =							\
+	test-devman.c
+
+test_devman_CPPFLAGS = \
+	$(AM_CPPFLAGS)
+
+test_devman_CFLAGS =							\
+	$(SETTINGS_PLUGIN_CFLAGS)					\
+	$(LIBWACOM_CFLAGS)						\
+	$(AM_CFLAGS)
+
+test_devman_LDADD = \
+	$(builddir)/libgsdwacomhelpers.la				\
+	$(SETTINGS_PLUGIN_LIBS)						\
+	$(LIBWACOM_LIBS)						\
+	$(NULL)
+
+plugin_in_files = wacom.gnome-settings-plugin.in
+
+plugin_DATA = $(plugin_in_files:.gnome-settings-plugin.in=.gnome-settings-plugin)
+
+EXTRA_DIST = $(plugin_in_files)
+CLEANFILES = $(plugin_DATA)
+DISTCLEANFILES = $(plugin_DATA)
+
+@GSD_INTLTOOL_PLUGIN_RULE@
diff -up gnome-settings-daemon-2.28.2/plugins/wacom/test-devman.c.wacom gnome-settings-daemon-2.28.2/plugins/wacom/test-devman.c
--- gnome-settings-daemon-2.28.2/plugins/wacom/test-devman.c.wacom	2012-03-05 16:52:15.286516073 -0500
+++ gnome-settings-daemon-2.28.2/plugins/wacom/test-devman.c	2012-03-05 16:52:15.286516073 -0500
@@ -0,0 +1,75 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2012 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+
+#include <glib/gi18n.h>
+#include <gtk/gtk.h>
+
+#include "gsd-wacom-devmanager-helpers.h"
+
+static void
+device_added_cb (GsdDeviceManager *device_manager,
+		 XDeviceInfo       *device,
+		 gpointer	  data)
+{
+	g_message ("Device %i (%s) added", (gint) device->id, device->name);
+}
+
+static void
+device_removed_cb (GsdDeviceManager *device_manager,
+		 XDeviceInfo       *device,
+		 gpointer	  data)
+{
+	g_message ("Device %i (%s) removed", (gint) device->id, device->name);
+}
+
+int
+main (int    argc,
+      char **argv)
+{
+	GError *error;
+	GsdDeviceManager *device_manager = NULL;
+	gint opcode;
+
+	error = NULL;
+	if (! gtk_init_with_args (&argc, &argv, NULL, NULL, NULL, &error)) {
+		fprintf (stderr, "%s", error->message);
+		g_error_free (error);
+		exit (1);
+	}
+
+	device_manager = gsd_display_get_device_manager (gdk_display_get_default ());
+
+	opcode = gsd_device_manager_get_opcode (device_manager);
+	g_signal_connect (G_OBJECT (device_manager), "device-added",
+			  G_CALLBACK (device_added_cb), device_manager);
+
+	g_signal_connect (G_OBJECT (device_manager), "device-removed",
+			  G_CALLBACK (device_removed_cb), device_manager);
+
+	gtk_main ();
+
+	return 0;
+}
diff -up gnome-settings-daemon-2.28.2/plugins/wacom/test-wacom.c.wacom gnome-settings-daemon-2.28.2/plugins/wacom/test-wacom.c
--- gnome-settings-daemon-2.28.2/plugins/wacom/test-wacom.c.wacom	2012-03-05 16:52:15.287516481 -0500
+++ gnome-settings-daemon-2.28.2/plugins/wacom/test-wacom.c	2012-03-05 16:52:15.286516073 -0500
@@ -0,0 +1,61 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 William Jon McCann <mccann@jhu.edu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+
+#include <glib/gi18n.h>
+#include <gtk/gtk.h>
+
+#include "gsd-wacom-manager.h"
+
+static GsdWacomManager *manager = NULL;
+
+int
+main (int    argc,
+      char **argv)
+{
+	GError  *error;
+
+	bindtextdomain (GETTEXT_PACKAGE, GNOME_SETTINGS_LOCALEDIR);
+	bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
+	textdomain (GETTEXT_PACKAGE);
+
+	g_setenv ("G_MESSAGES_DEBUG", "all", TRUE);
+
+	error = NULL;
+	if (! gtk_init_with_args (&argc, &argv, NULL, NULL, NULL, &error)) {
+		fprintf (stderr, "%s", error->message);
+		g_error_free (error);
+		exit (1);
+	}
+
+	manager = gsd_wacom_manager_new ();
+
+	error = NULL;
+	gsd_wacom_manager_start (manager, &error);
+
+	gtk_main ();
+
+	return 0;
+}
diff -up gnome-settings-daemon-2.28.2/plugins/wacom/wacom.gnome-settings-plugin.in.wacom gnome-settings-daemon-2.28.2/plugins/wacom/wacom.gnome-settings-plugin.in
--- gnome-settings-daemon-2.28.2/plugins/wacom/wacom.gnome-settings-plugin.in.wacom	2012-03-05 16:52:15.287516481 -0500
+++ gnome-settings-daemon-2.28.2/plugins/wacom/wacom.gnome-settings-plugin.in	2012-03-05 16:52:15.287516481 -0500
@@ -0,0 +1,8 @@
+[GNOME Settings Plugin]
+Module=gsdwacom
+IAge=0
+_Name=Wacom
+_Description=Wacom plugin
+Authors=Peter Hutterer
+Copyright=Copyright © 2010
+Website=
diff -up gnome-settings-daemon-2.28.2/po/POTFILES.in.wacom gnome-settings-daemon-2.28.2/po/POTFILES.in
--- gnome-settings-daemon-2.28.2/po/POTFILES.in.wacom	2010-03-10 06:38:16.000000000 -0500
+++ gnome-settings-daemon-2.28.2/po/POTFILES.in	2012-03-05 16:52:15.287516481 -0500
@@ -7,7 +7,6 @@ data/apps_gnome_settings_daemon_xrandr.s
 data/desktop_gnome_font_rendering.schemas.in
 data/desktop_gnome_keybindings.schemas.in
 data/desktop_gnome_peripherals_touchpad.schemas.in
-data/gnome-settings-daemon.desktop.in.in
 data/gnome-settings-daemon.schemas.in
 gnome-settings-daemon/main.c
 [type: gettext/ini]plugins/a11y-keyboard/a11y-keyboard.gnome-settings-plugin.in
@@ -32,6 +31,9 @@ plugins/media-keys/cut-n-paste/gvc-mixer
 plugins/mouse/gsd-mouse-manager.c
 [type: gettext/ini]plugins/mouse/mouse.gnome-settings-plugin.in
 [type: gettext/ini]plugins/typing-break/typing-break.gnome-settings-plugin.in
+plugins/wacom/gsd-wacom-manager.c
+plugins/wacom/gsd-wacom-rr-helpers.c
+[type: gettext/ini]plugins/wacom/wacom.gnome-settings-plugin.in
 [type: gettext/ini]plugins/xrandr/xrandr.gnome-settings-plugin.in
 plugins/xrandr/gsd-xrandr-manager.c
 plugins/xrdb/gsd-xrdb-manager.c
